<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>Cogent Usage Examples</title>
<style type="text/css">

  #contents {
      background: rgb(255, 255, 255);
      color: rgb(0, 0, 0);
      line-height: 140%;
      font-size: 140%;
      font-family: "Hoefler Text";
  }
  blockquote { border-left: 5px solid rgb(204, 204, 204);
    margin-left: 1.5em;
    padding-left: 5px;
    }

  body { background: rgb(255, 255, 255) none repeat scroll 0% 50%;
    color: rgb(0, 0, 0);
    font-size: 12pt;
    line-height: 12pt;
    font-family: "Baskerville";
    }
  
    @media screen {
        body {
        margin-left: 4%;
        margin-right: 4%;
        }
        h1.title {
          text-align: center;
          }
        
        pre.code {
            background-color: rgb(238, 238, 238);
            }
    }
    
    @media print {
        body {
             page-break-inside: auto;
             text-align: justify;
             bottom-right: counter(page);
             margin-left: 1cm;
             margin-right: 1cm;
            }
        h1.title {
              text-align: left;
              }
        pre.code {
            background-color: rgb(255, 255, 255);
            }
        }

  cite { font-size: 90%;
    font-style: normal;
    }

  h1 { font-family: "Hoefler Text";
    background-color: #E6E6E6;
    line-height: 140%;
    font-size: 140%;
    }
  h1.title {
    font-family: "Hoefler Text";
    background-color: #E6E6E6;
    line-height: 180%;
    font-size: 180%;
  }
  h2 { border-bottom: 1px dotted rgb(204, 204, 204);
    margin: 15px 0pt 2px;
    letter-spacing: 0.2em;
    padding-bottom: 2px;
    font-size: 140%;
    }

    h3 { border-bottom: 1px dotted rgb(238, 238, 238);
      margin-top: 0pt;
      font-size: 120%;
      }

    h4 { border-bottom: 1px dotted rgb(238, 238, 238);
    margin-top: 0pt;
    font-size: 110%;
    }

  p, li, .feedback { font-style: normal;
    font-variant: normal;
    font-weight: normal;
    font-size-adjust: none;
    font-family: normal;
    font-size: 100%;
    line-height: 100%;
    }

  ul.post-meta { list-style-type: none;
    list-style-image: none;
    list-style-position: outside;
    }

  ul.post-meta span.post-meta-key { font-weight: bold;
    }

  .copyright { font-size: 11px;
    }

  .credit { border: medium solid rgb(68, 68, 68);
    margin: 0pt 19em 0pt 0pt;
    padding: 0.25em;
    background: rgb(232, 232, 232) none repeat scroll 0% 50%;
    -moz-background-clip: initial;
    -moz-background-origin: initial;
    -moz-background-inline-policy: initial;
    display: none;
    font-size: 11px;
    text-align: center;
    line-height: 100%;
    height: 33px;
    }

  .credit a:link, .credit a:hover { color: rgb(255, 255, 255);
    }

  .feedback { color: rgb(204, 204, 204);
    text-align: right;
    }

  .meta { font-size: 0.75em;
    }

  .meta li, ul.post-meta li { display: inline;
    }

  .meta ul { margin: 0pt;
    padding: 0pt;
    display: inline;
    list-style-type: none;
    list-style-image: none;
    list-style-position: outside;
    }

  .meta, .meta a { color: rgb(128, 128, 128);
    font-weight: normal;
    letter-spacing: 0pt;
    }

  .storytitle { margin: 0pt;
    }

  .storytitle a { text-decoration: none;
    }

    tt {
    font-family: Monaco;
        font-size: 82%;
    }
    
    dt {
        font-weight: bold;
    }
  pre.code { padding: 0em;
    font-family: Monaco;
    white-space: pre;
    color: rgb(17, 17, 17);
    width: 100%;
    line-height: 100%;
    font-size: 82%;
    }

  span.py_keyword { color: rgb(192, 0, 0);
    }

  span.py_string { color: rgb(0, 64, 128);
    }

  span.py_comment { color: rgb(0, 128, 0);
    }

  span.py_identifier { color: rgb(0, 0, 192);
    }

    table { border: 0px none ;
      text-align: center;
      font-weight: normal;
      color: rgb(255, 255, 255);
      background-color: rgb(102, 102, 102);
      border-collapse: collapse;
      -x-border-x-spacing: 0px;
      -x-border-y-spacing: 0px;
      font-family: Times New Roman,Times,serif;
      font-size: 12pt;
      line-height: 12pt;
      }

    table td { border: 1px solid rgb(255, 255, 255);
      padding: 4px;
      background-color: rgb(204, 204, 204);
      color: rgb(0, 0, 0);
      text-align: left;
      font-family: Times New Roman,Times,serif;
      font-size: 12pt;
      line-height: 12pt;
      }

    table td.hed { border-bottom: 2px solid rgb(255, 255, 255);
      padding: 4px;
      background-color: rgb(102, 102, 102);
      color: rgb(255, 255, 255);
      text-align: left;
      font-weight: bold;
      font-family: Times New Roman,Times,serif;
      font-size: 12pt;
      line-height: 12pt;
      }

</style>
</head>
<body>
<div class="document" id="cogent-usage-examples">
<h1 class="title">Cogent Usage Examples</h1>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#the-readme" id="id3" name="id3">The Readme</a><ul>
<li><a class="reference" href="#cogent-comparative-genomics-toolkit-install" id="id4" name="id4"><cite>COGENT</cite> (COmparative GENomics Toolkit) Install</a><ul>
<li><a class="reference" href="#dependencies" id="id5" name="id5">Dependencies</a></li>
<li><a class="reference" href="#installation" id="id6" name="id6">Installation</a></li>
<li><a class="reference" href="#testing" id="id7" name="id7">Testing</a></li>
<li><a class="reference" href="#tips-for-usage" id="id8" name="id8">Tips for usage</a></li>
<li><a class="reference" href="#citation" id="id9" name="id9">Citation</a></li>
<li><a class="reference" href="#licenses-and-disclaimer" id="id10" name="id10">Licenses and disclaimer</a></li>
<li><a class="reference" href="#contacts" id="id11" name="id11">Contacts</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#a-note-on-the-computable-documentation" id="id12" name="id12">A Note on the Computable Documentation</a></li>
<li><a class="reference" href="#data-manipulation" id="id13" name="id13">Data manipulation</a><ul>
<li><a class="reference" href="#translating-dna-into-protein" id="id14" name="id14">Translating DNA into protein</a></li>
<li><a class="reference" href="#advanced-sequence-handling" id="id15" name="id15">Advanced sequence handling</a></li>
<li><a class="reference" href="#getting-the-reverse-complement" id="id16" name="id16">Getting the reverse complement</a></li>
<li><a class="reference" href="#map-protein-alignment-gaps-to-dna-alignment-gaps" id="id17" name="id17">Map protein alignment gaps to DNA alignment gaps</a></li>
<li><a class="reference" href="#creating-and-manipulating-alignment-profiles" id="id18" name="id18">Creating and manipulating alignment profiles</a></li>
<li><a class="reference" href="#compute-the-effect-of-a-nucleotide-substitution-on-residue-polarity-in-two-different-genetic-codes-using-geneticcode-and-aaindex" id="id19" name="id19">Compute the effect of a nucleotide substitution on residue polarity in two different genetic codes using GeneticCode and AAIndex</a></li>
<li><a class="reference" href="#data-manipulation-using-table" id="id20" name="id20">Data Manipulation using <tt class="docutils literal"><span class="pre">Table</span></tt></a><ul>
<li><a class="reference" href="#testing-a-sub-component" id="id21" name="id21">Testing a sub-component</a></li>
<li><a class="reference" href="#table-creation" id="id22" name="id22">Table creation</a></li>
<li><a class="reference" href="#table-output" id="id23" name="id23">Table output</a></li>
<li><a class="reference" href="#saving-a-table-for-reloading" id="id24" name="id24">Saving a table for reloading</a></li>
<li><a class="reference" href="#table-slicing-and-iteration" id="id25" name="id25">Table slicing and iteration</a></li>
<li><a class="reference" href="#filtering-tables-selecting-subsets-of-rows" id="id26" name="id26">Filtering tables - selecting subsets of rows</a></li>
<li><a class="reference" href="#appending-tables" id="id27" name="id27">Appending tables</a></li>
<li><a class="reference" href="#miscellaneous" id="id28" name="id28">Miscellaneous</a></li>
<li><a class="reference" href="#extending-tables" id="id29" name="id29">Extending tables</a></li>
<li><a class="reference" href="#sorting-tables" id="id30" name="id30">Sorting tables</a></li>
<li><a class="reference" href="#joining-tables" id="id31" name="id31">Joining Tables</a></li>
<li><a class="reference" href="#counting-rows" id="id32" name="id32">Counting rows</a></li>
<li><a class="reference" href="#cleanup" id="id33" name="id33">Cleanup</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#data-visualisation" id="id34" name="id34">Data Visualisation</a><ul>
<li><a class="reference" href="#drawing-dendrograms-and-saving-to-pdf" id="id35" name="id35">Drawing dendrograms and saving to PDF</a></li>
<li><a class="reference" href="#drawing-a-dotplot" id="id36" name="id36">Drawing a dotplot</a></li>
</ul>
</li>
<li><a class="reference" href="#modelling-evolution" id="id37" name="id37">Modelling Evolution</a><ul>
<li><a class="reference" href="#the-simplest-script" id="id38" name="id38">The simplest script</a></li>
<li><a class="reference" href="#performing-a-relative-rate-test" id="id39" name="id39">Performing a relative rate test</a></li>
<li><a class="reference" href="#a-test-of-the-neutral-theory" id="id40" name="id40">A test of the neutral theory</a></li>
<li><a class="reference" href="#use-an-empirical-protein-substitution-model" id="id41" name="id41">Use an empirical protein substitution model</a></li>
<li><a class="reference" href="#analysis-of-rate-heterogeneity" id="id42" name="id42">Analysis of rate heterogeneity</a></li>
<li><a class="reference" href="#likelihood-analysis-of-multiple-loci" id="id43" name="id43">Likelihood analysis of multiple loci</a></li>
<li><a class="reference" href="#reusing-results-to-speed-up-optimisation" id="id44" name="id44">Reusing results to speed up optimisation</a></li>
<li><a class="reference" href="#specifying-and-using-an-restricted-nucleotide-substitution-model" id="id45" name="id45">Specifying and using an restricted nucleotide substitution model</a></li>
<li><a class="reference" href="#simulate-an-alignment" id="id46" name="id46">Simulate an alignment</a></li>
<li><a class="reference" href="#performing-a-parametric-bootstrap" id="id47" name="id47">Performing a parametric bootstrap</a></li>
<li><a class="reference" href="#estimate-parameter-values-using-a-sampling-from-a-dataset" id="id48" name="id48">Estimate parameter values using a sampling from a dataset</a></li>
</ul>
</li>
<li><a class="reference" href="#phylogenetic-reconstruction" id="id49" name="id49">Phylogenetic Reconstruction</a><ul>
<li><a class="reference" href="#calculate-pairwise-distances-between-sequences" id="id50" name="id50">Calculate pairwise distances between sequences</a></li>
<li><a class="reference" href="#make-a-neighbor-joining-tree" id="id51" name="id51">Make a neighbor joining tree</a></li>
<li><a class="reference" href="#phylogenetic-reconstruction-by-least-squares" id="id52" name="id52">Phylogenetic reconstruction by least squares</a><ul>
<li><a class="reference" href="#look-for-the-single-best-tree" id="id53" name="id53">Look for the single best tree</a></li>
<li><a class="reference" href="#a-more-rigourous-tree-space-search" id="id54" name="id54">A more rigourous tree space search</a></li>
<li><a class="reference" href="#assessing-the-fit-for-a-pre-specified-tree-topology" id="id55" name="id55">Assessing the fit for a pre-specified tree topology</a></li>
<li><a class="reference" href="#using-maximum-likelihood-for-measuring-tree-fit" id="id56" name="id56">Using maximum likelihood for measuring tree fit</a></li>
</ul>
</li>
<li><a class="reference" href="#making-a-phylogenetic-tree-from-a-protein-sequence-alignment" id="id57" name="id57">Making a phylogenetic tree from a protein sequence alignment</a></li>
</ul>
</li>
<li><a class="reference" href="#python-coding-guidelines" id="id58" name="id58">Python Coding Guidelines</a><ul>
<li><a class="reference" href="#why-have-coding-guidelines" id="id59" name="id59">Why have coding guidelines?</a><ul>
<li><a class="reference" href="#what-should-i-call-my-variables" id="id60" name="id60">What should I call my variables?</a><ul>
<li><a class="reference" href="#acceptable-abbreviations" id="id61" name="id61">Acceptable abbreviations</a></li>
</ul>
</li>
<li><a class="reference" href="#what-are-the-naming-conventions" id="id62" name="id62">What are the naming conventions?</a></li>
<li><a class="reference" href="#how-do-i-organize-my-modules-source-files" id="id63" name="id63">How do I organize my modules (source files)?</a><ul>
<li><a class="reference" href="#example-of-module-structure" id="id64" name="id64">Example of module structure</a></li>
</ul>
</li>
<li><a class="reference" href="#how-should-i-write-comments" id="id65" name="id65">How should I write comments?</a></li>
<li><a class="reference" href="#how-should-i-format-my-code" id="id66" name="id66">How should I format my code?</a></li>
<li><a class="reference" href="#how-should-i-test-my-code" id="id67" name="id67">How should I test my code ?</a><ul>
<li><a class="reference" href="#some-unittest-pointers" id="id68" name="id68">Some <tt class="docutils literal"><span class="pre">unittest</span></tt> pointers</a></li>
<li><a class="reference" href="#example-of-a-unittest-test-module-structure" id="id69" name="id69">Example of a <tt class="docutils literal"><span class="pre">unittest</span></tt> test module structure</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id3" id="the-readme" name="the-readme">The Readme</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id4" id="cogent-comparative-genomics-toolkit-install" name="cogent-comparative-genomics-toolkit-install"><cite>COGENT</cite> (COmparative GENomics Toolkit) Install</a></h2>
<!-- This document is written in `restructured text`_ format. A html version, including examples cogent.html located in the doc directory, is automatically created when the project tarball is built. -->
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Gavin Huttley, Rob Knight</td>
</tr>
<tr class="field"><th class="field-name">Address:</th><td class="field-body">John Curtin School of Medical Research,
Australian National University, Canberra, ACT 0200, Australia.
Department of Chemistry and Biochemistry,
University of Colorado, Boulder, CO 80309-0215, USA.</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">1.0.1</td>
</tr>
<tr class="field"><th class="field-name">Copyright:</th><td class="field-body">This software is copyright 2002-2007.</td>
</tr>
<tr class="field"><th class="field-name">Download:</th><td class="field-body">Download from <a class="reference" href="http://sourceforge.net/forum/forum.php?forum_id=651121">here</a>.</td>
</tr>
<tr class="field"><th class="field-name">Registration:</th><td class="field-body">To be informed of bugs, new releases please subscribe to the mailing lists at sourceforge.</td>
</tr>
</tbody>
</table>
<div class="section">
<h3><a class="toc-backref" href="#id5" id="dependencies" name="dependencies">Dependencies</a></h3>
<p>The toolkit requires Python 2.4.3 or greater, and Numpy 1.0 or greater. Aside from these the dependencies below are optional and the code will work as is. A C compiler, however, will allow external C module's responsible for the likelihood and matrix exponentiation calculations to be compiled, resulting in significantly improved performance.</p>
<p><strong>For non-geeks:</strong> The best way to install these dependencies depends on your platform. For MacOS X users, we suggest you install MacPython (see the <a class="reference" href="http://www.python.org">python</a> home page) as it also contains a package manager that can ease installation of some of the dependencies.</p>
<dl class="docutils">
<dt><cite>Required</cite></dt>
<dd><ul class="first last">
<li><p class="first"><a class="reference" href="http://www.python.org">Python</a>: the language the toolkit is primarily written in, and in which the user writes control scripts.</p>
</li>
<li><p class="first"><a class="reference" href="http://www.scipy.org/NumPy">Numpy</a>: This is a python module used for speeding up matrix computations. It is available as source code for *nix. <strong>NOTE:</strong> For installing Numpy, unless you know what you are doing we recommend not linking Numpy against ATLAS or LAPACK libraries. On systems where these have been installed, this can be achieved by setting shell environment variables prior to building Numpy as:</p>
<pre class="literal-block">
$ export ATLAS=None
$ export LAPACK=None
</pre>
</li>
</ul>
</dd>
<dt><cite>Optional</cite></dt>
<dd><ul class="first last simple">
<li>C compiler: This is standard on most *nix platforms. On Macos X this is available for free in the Developer tools which, if you don't already have them, can be obtained from <a class="reference" href="http://www.apple.com">Apple</a>, or get MacPython and use the package manager.</li>
<li><a class="reference" href="http://reportlab.org">ReportLab</a>: required for drawing trees and alignments to pdf.</li>
<li><a class="reference" href="http://matplotlib.sourceforge.net">Matplotlib</a>: used to plot several kinds of graphs related to codon usage.</li>
<li><a class="reference" href="http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/">Pyrex</a>: This module is only necessary if you are a developer who wants to modify the *.pyx files.</li>
<li><a class="reference" href="http://jcsmr.anu.edu.au/org/dmb/compgen/software.php">PyxMPI</a>: Our own python MPI interface, required for parallel computation.</li>
</ul>
</dd>
</dl>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id6" id="installation" name="installation">Installation</a></h3>
<p>For *nix platforms (including MacOS X), installation of the software is conventional for python packages. Download the software from <a class="reference" href="http://sourceforge.net/forum/forum.php?forum_id=651121">here</a>. Uncompress the archive and change into the <tt class="docutils literal"><span class="pre">Cogent</span></tt> directory and type:</p>
<pre class="literal-block">
$ python setup.py build
</pre>
<p>This automatically compiles the modules. If you have administrative privileges type:</p>
<pre class="literal-block">
$ sudo python setup.py install
</pre>
<p>This then places the entire package into your python/site-packages folder.</p>
<p>If you do not have administrator privileges on your machine you can move the cogent directory to where you want it (or leave it in place) and add this location to your python path using <tt class="docutils literal"><span class="pre">sys.path.append(&quot;/your/path/to/Cogent&quot;)</span></tt> in each script, or by setting shell environment variables. (Note that the path is not to <tt class="docutils literal"><span class="pre">../Cogent/cogent</span></tt>.)</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id7" id="testing" name="testing">Testing</a></h3>
<p><tt class="docutils literal"><span class="pre">Cogent/tests</span></tt> contains all the tests (currently &gt;2700). You can most readily run the tests using the <tt class="docutils literal"><span class="pre">Cogent/run_tests</span></tt> shell script. This is done by typing:</p>
<pre class="literal-block">
$ sh run_tests
</pre>
<p>which will automatically build extensions in place, set up the PYTHONPATH and run <tt class="docutils literal"><span class="pre">Cogent/tests/alltests.py</span></tt>. Note that if certain optional applications are not installed this will be indicated in the output as &quot;can't find&quot; or &quot;not installed&quot;. A <cite>.</cite> will be printed to screen for each test and if they all pass, you'll see output like:</p>
<p>Ran 1982 tests in 40.455s</p>
<p>OK</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id8" id="tips-for-usage" name="tips-for-usage">Tips for usage</a></h3>
<p>A good IDE can greatly simplify writing control scripts. Features such as code completion and definition look-up are extremely useful. Amongst the freeware editors are <a class="reference" href="http://www.jedit.org">Jedit</a> (runs on all platforms, and has plugins to provide an overview of code structure or to organise projects), <a class="reference" href="http://www.codingmonkeys.de/subethaedit/">SubEthaEdit</a> (MacOS X only) and of course <a class="reference" href="http://www.gnu.org/software/emacs/emacs.html">emacs</a> (all platforms). These provide syntax highlighting for Python, automated code indentation and (Jedit and emacs) code-folding abilities. For a more complete list of <a class="reference" href="http://www.python.org/cgi-bin/moinmoin/PythonEditors">editors go here</a>.</p>
<p>To get help on attributes of an object in python, use the <tt class="docutils literal"><span class="pre">dir(myalign)</span></tt> to list the attributes of <tt class="docutils literal"><span class="pre">myalign</span></tt> or <tt class="docutils literal"><span class="pre">help(myalign.writeToFile)</span></tt> to figure out how to use the <tt class="docutils literal"><span class="pre">myalign.writeToFile</span></tt> method. Also note that the directory structure of the package is similar to the import statements required to use a module -- to see the contents of <tt class="docutils literal"><span class="pre">alignment.py</span></tt> or <tt class="docutils literal"><span class="pre">sequence.py</span></tt> you need to look in the directory <tt class="docutils literal"><span class="pre">cogent/core</span></tt> path, to use the classes in those files you specify <tt class="docutils literal"><span class="pre">cogent.core</span></tt> for importing.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id9" id="citation" name="citation"><span id="pyevolve"></span>Citation</a></h3>
<p>If you use this software for published work please cite either --  R. Knight, P. Maxwell, A. Birmingham, J. Carnes, J. Caporaso, B. Easton, M. Hamady, H. Lindsay, Z. Liu, C. Lozupone, R. Sammut, S. Smit, M. Wakefield, J. Widmann, S. Wikman, S. Wilson, H. Ying, and G. Huttley. PyCogent: a toolkit for making sense from sequence. Genome Biol, In press, 2007.; or, Butterfield, A., V. Vedagiri, E. Lang, C. Lawrence, M.J. Wakefield, A. Isaev, and G.A. Huttley, PyEvolve: a toolkit for statistical modelling of molecular evolution. <cite>BMC Bioinformatics</cite>, 2004. <strong>5(1):</strong> p. 1</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id10" id="licenses-and-disclaimer" name="licenses-and-disclaimer">Licenses and disclaimer</a></h3>
<p>COGENT is released under the GPL license, a copy of which is <a class="reference" href="EVOLVE_LICENSE.txt">included</a> in the distribution. A copy of the permission to use the matrix exponentiation code from <a class="reference" href="MATRIX_LICENSE.txt">PAML</a> is also included. Licenses for other code sources are left in place.</p>
<p>This software is provided &quot;as-is&quot;. There are no expressed or implied warranties of any kind, including, but not limited to, the warranties of merchantability and fitness for a given application. In no event shall the authors be liable for any direct, indirect, incidental, special, exemplary or consequential damages (including, but not limited to, loss of use, data or profits, or business interruption) however caused and on any theory of liability, whether in contract, strict liability or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id11" id="contacts" name="contacts">Contacts</a></h3>
<p>If you find a bug or have feature requests, please post comments on the corresponding <a class="reference" href="http://sourceforge.net/tracker2/?group_id=186234">tracker</a> page at sourceforge. If you have any questions please post on the appropriate projects <a class="reference" href="http://sourceforge.net/forum/?group_id=186234">forums</a> page at sourceforge.</p>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id12" id="a-note-on-the-computable-documentation" name="a-note-on-the-computable-documentation">A Note on the Computable Documentation</a></h1>
<p>The following examples are all available as standalone text files which can be computed using the Python doctest module. One caveat with these tests is a subset will fail sporadically (or even consistently), although there is nothing 'wrong' with the software. These failures arise because of the typically very small data-sets we use in order for the documentation to compute in a short time period. As a result of their small size, the results from numerical optimisations are volatile and can change from one run to another -- leading to 'failures'. Specific examples that are prone to these problems involve the HMM models, the test of Neutrality, rate heterogeneity, unrestricted nucleotide substitution model and even the simplest example.</p>
<p>Examples not explicitly attributed were authored by Gavin Huttley.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id13" id="data-manipulation" name="data-manipulation">Data manipulation</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id14" id="translating-dna-into-protein" name="translating-dna-into-protein">Translating DNA into protein</a></h2>
<p>To translate a DNA alignment, read it in assigning the DNA alphabet. Note setting <tt class="docutils literal"><span class="pre">aligned</span> <span class="pre">=</span> <span class="pre">False</span></tt> is critical for loading sequences of unequal length. Different genetic codes are available in <tt class="docutils literal"><span class="pre">cogent.core.genetic_code</span></tt></p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs, DNA
&gt;&gt;&gt; al = LoadSeqs(<span class="py_string">'data/test2.fasta'</span>, moltype=DNA, aligned = <span class="py_keyword">False</span>)
&gt;&gt;&gt; pal = al.getTranslation()
&gt;&gt;&gt; <span class="py_keyword">print</span> pal.toFasta()
&gt;DogFaced
ARSQQNRWVETKETCNDRQT
&gt;HowlerMon
ARSQHNRWAESEETCNDRQT
&gt;Human
ARSQHNRWAGSKETCNDRRT
&gt;Mouse
AVSQQSRWAASKGTCNDRQV
&gt;NineBande
RQQSRWAESKETCNDRQT</pre><p>To save this result to a file, use the <tt class="docutils literal"><span class="pre">writeToFile</span></tt> method.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id15" id="advanced-sequence-handling" name="advanced-sequence-handling">Advanced sequence handling</a></h2>
<p>Individual sequences and alignments can be manipulated by annotations. Most value in the genome sequences arises from sequence annotations regarding specific sequence feature types, e.g. genes with introns / exons, repeat sequences. These can be applied to an alignment either using data formats available from genome portals (e.g. GFF, or GenBank annotation formats) or by custom assignments.</p>
<p>Annotations can be added in two ways: using either the <tt class="docutils literal"><span class="pre">addAnnotation</span></tt> or the <tt class="docutils literal"><span class="pre">addFeature</span></tt> method. The distinction between these two is that <tt class="docutils literal"><span class="pre">addFeatures</span></tt> is more specialised. Features can be thought of as a type of annotation representing standard sequence properties eg introns/exons. Annotations are the more general case, such as a computed property which has, say a numerical value and a span.</p>
<p>For illustrative purposes we define a sequence with 2 exons and grab the 1<sup>st</sup> exon:</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> DNA
&gt;&gt;&gt; s = DNA.makeSequence(<span class="py_string">"aagaagaagacccccaaaaaaaaaattttttttttaaaaaaaaaaaaa"</span>,
... Name=<span class="py_string">"Orig"</span>)
&gt;&gt;&gt; exon1 = s.addFeature(<span class="py_string">'exon'</span>, <span class="py_string">'exon1'</span>, [(10,15)])
&gt;&gt;&gt; exon2 = s.addFeature(<span class="py_string">'exon'</span>, <span class="py_string">'exon2'</span>, [(30,40)])</pre><p>Here, '<tt class="docutils literal"><span class="pre">exon</span></tt>' is the feature type, and '<tt class="docutils literal"><span class="pre">exon#</span></tt>' the feature name. The feature type is used for the display formatting, which won't be illustrated here, and also for selecting all features of the same type, shown below.</p>
<p>We could also have created an annotation using the <tt class="docutils literal"><span class="pre">addAnnotation</span></tt> method:</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.core.annotation <span class="py_keyword">import</span> Feature
&gt;&gt;&gt; s2=DNA.makeSequence(<span class="py_string">"aagaagaagacccccaaaaaaaaaattttttttttaaaaaaaaaaaaa"</span>,
... Name=<span class="py_string">"Orig2"</span>)
&gt;&gt;&gt; exon3 = s2.addAnnotation(Feature, <span class="py_string">'exon'</span>, <span class="py_string">'exon1'</span>, [(35,40)])</pre><p>We can use the features (eg <tt class="docutils literal"><span class="pre">exon1</span></tt>) to get the corresponding sequence region.</p>
<pre class="code">&gt;&gt;&gt; s[exon1]
DnaSequence(CCCCC)</pre><p>You can query annotations by type and optionally by label, receiving a list of features:</p>
<pre class="code">&gt;&gt;&gt; exons = s.getAnnotationsMatching(<span class="py_string">'exon'</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> exons
[exon <span class="py_string">"exon1"</span> at [10:15]/48, exon <span class="py_string">"exon2"</span> at [30:40]/48]</pre><p>We can use this list to construct a pseudo-feature covering (or excluding) multiple features using <tt class="docutils literal"><span class="pre">getRegionCoveringAll</span></tt>. For instance, getting all exons,</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> s.getRegionCoveringAll(exons)
region <span class="py_string">"exon"</span> at [10:15, 30:40]/48
&gt;&gt;&gt; s.getRegionCoveringAll(exons).getSlice()
DnaSequence(CCCCCTT... 15)</pre><p>or not exons (the exon <em>shadow</em>):</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> s.getRegionCoveringAll(exons).getShadow().getSlice()
AAGAAGAAGAAAAAAAAAAATTTTTAAAAAAAA</pre><p>The first of these essentially returns the CDS of the gene.</p>
<p>Features are themselves sliceable:</p>
<pre class="code">&gt;&gt;&gt; exon1[0:3].getSlice()
DnaSequence(CCC)</pre><p>This approach to sequence / alignment handling allows the user to manipulate them according to things they know about such as genes or repeat elements. Most of this annotation data can be obtained from genome portals.</p>
<p>The toolkit can perform standard sequence / alignment manipulations such as getting a subset of sequences or aligned columns, translating sequences, reading and writing standard formats.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id16" id="getting-the-reverse-complement" name="getting-the-reverse-complement">Getting the reverse complement</a></h2>
<p>This is a property of DNA, and hence alignments need to be created with the appropriate <tt class="docutils literal"><span class="pre">MolType</span></tt>. In the following example, the alignment is truncated to just 100 bases for the sake of simplifying the presentation.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs, DNA
&gt;&gt;&gt; aln = LoadSeqs(<span class="py_string">"data/long_testseqs.fasta"</span>, moltype=DNA)[:100]</pre><p>The original alignment looks like this.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> aln
&gt;FlyingFox
TGTGGCACAAATGCTCATGCCAGCTCTTTACAGCATGAGAAC---AGTTTATTATACACTAAAGACAGAATGAATGTAGAAAAGACTGACTTCTGTAATA
&gt;DogFaced
TGTGGCACAAATACTCATGCCAACTCATTACAGCATGAGAACAGCAGTTTATTATACACTAAAGACAGAATGAATGTAGAAAAGACTGACTTCTGTAATA</pre><p>We do reverse complement very simply.</p>
<pre class="code">&gt;&gt;&gt; naln = aln.rc()</pre><p>The reverse complemented alignment looks like this.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> naln
&gt;FlyingFox
TATTACAGAAGTCAGTCTTTTCTACATTCATTCTGTCTTTAGTGTATAATAAACT---GTTCTCATGCTGTAAAGAGCTGGCATGAGCATTTGTGCCACA
&gt;DogFaced
TATTACAGAAGTCAGTCTTTTCTACATTCATTCTGTCTTTAGTGTATAATAAACTGCTGTTCTCATGCTGTAATGAGTTGGCATGAGTATTTGTGCCACA
</pre></div>
<div class="section">
<h2><a class="toc-backref" href="#id17" id="map-protein-alignment-gaps-to-dna-alignment-gaps" name="map-protein-alignment-gaps-to-dna-alignment-gaps">Map protein alignment gaps to DNA alignment gaps</a></h2>
<p>Although PyCogent provides a means for directly aligning codon sequences, you may want to use a different approach based on the translate-align-introduce gaps into the original paradigm. After you've translated your codon sequences, and aligned the resulting amino acid sequences, you want to introduce the gaps from the aligned protein sequences back into the original codon sequences. Here's how.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs, DNA, PROTEIN</pre><p>First I'm going to construct an artificial example, using the seqs dict as a means to get the data into the Alignment object. The basic idea, however, is that you should already have a set of DNA sequences that are in frame (i.e. position 0 is the 1st codon position), you've translated those sequences and aligned these translated sequences. The result is an alignment of aa sequences and a set of unaligned DNA sequences from which the aa seqs were derived. If your sequences are not in frame you can adjust it by either slicing, or adding N's to the beginning of the raw string.</p>
<pre class="code">&gt;&gt;&gt; seqs = {
... <span class="py_string">'hum'</span>: <span class="py_string">'AAGCAGATCCAGGAAAGCAGCGAGAATGGCAGCCTGGCCGCGCGCCAGGAGAGGCAGGCCCAGGTCAACCTCACT'</span>,
... <span class="py_string">'mus'</span>: <span class="py_string">'AAGCAGATCCAGGAGAGCGGCGAGAGCGGCAGCCTGGCCGCGCGGCAGGAGAGGCAGGCCCAAGTCAACCTCACG'</span>,
... <span class="py_string">'rat'</span>: <span class="py_string">'CTGAACAAGCAGCCACTTTCAAACAAGAAA'</span>}
&gt;&gt;&gt; unaligned_DNA = LoadSeqs(data=seqs, moltype = DNA, aligned = <span class="py_keyword">False</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> unaligned_DNA.toFasta()
&gt;hum
AAGCAGATCCAGGAAAGCAGCGAGAATGGCAGCCTGGCCGCGCGCCAGGAGAGGCAGGCCCAGGTCAACCTCACT
&gt;mus
AAGCAGATCCAGGAGAGCGGCGAGAGCGGCAGCCTGGCCGCGCGGCAGGAGAGGCAGGCCCAAGTCAACCTCACG
&gt;rat
CTGAACAAGCAGCCACTTTCAAACAAGAAA</pre><p>In order to ensure the alignment algorithm preserves the coding frame, we align the translation of the sequences. We need to translate them first, but note that because the seqs are unaligned they we have to set <tt class="docutils literal"><span class="pre">aligned</span> <span class="pre">=</span> <span class="pre">False</span></tt>, or we'll get an error.</p>
<pre class="code">&gt;&gt;&gt; unaligned_aa = unaligned_DNA.getTranslation()
&gt;&gt;&gt; <span class="py_keyword">print</span> unaligned_aa.toFasta()
&gt;hum
KQIQESSENGSLAARQERQAQVNLT
&gt;mus
KQIQESGESGSLAARQERQAQVNLT
&gt;rat
LNKQPLSNKK</pre><p>The translated seqs can then be written to file, using the method <tt class="docutils literal"><span class="pre">writeToFile</span></tt>. That file then serves as input for an alignment program. The resulting alignment file can be read back in. (We won't write to file in this example.) For this example we will specify the aligned sequences in the dict, rather than from file.</p>
<pre class="code">&gt;&gt;&gt; aligned_aa_seqs = {<span class="py_string">'hum'</span>: <span class="py_string">'KQIQESSENGSLAARQERQAQVNLT'</span>,
... <span class="py_string">'mus'</span>: <span class="py_string">'KQIQESGESGSLAARQERQAQVNLT'</span>,
... <span class="py_string">'rat'</span>: <span class="py_string">'LNKQ------PLS---------NKK'</span>}
&gt;&gt;&gt; aligned_aa = LoadSeqs(data = aligned_aa_seqs, moltype = PROTEIN)
&gt;&gt;&gt; aligned_DNA = aligned_aa.replaceSeqs(unaligned_DNA)</pre><p>Just to be sure, we'll check that the DNA sequence has gaps in the right place.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> aligned_DNA
&gt;hum
AAGCAGATCCAGGAAAGCAGCGAGAATGGCAGCCTGGCCGCGCGCCAGGAGAGGCAGGCCCAGGTCAACCTCACT
&gt;rat
CTGAACAAGCAG------------------CCACTTTCA---------------------------AACAAGAAA
&gt;mus
AAGCAGATCCAGGAGAGCGGCGAGAGCGGCAGCCTGGCCGCGCGGCAGGAGAGGCAGGCCCAAGTCAACCTCACG
</pre></div>
<div class="section">
<h2><a class="toc-backref" href="#id18" id="creating-and-manipulating-alignment-profiles" name="creating-and-manipulating-alignment-profiles">Creating and manipulating alignment profiles</a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Sandra Smit</td>
</tr>
</tbody>
</table>
<p>This is an example of how to create a profile from an alignment and how to do particular tricks with it. First, import the necessary stuff.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.core.profile <span class="py_keyword">import</span> Profile
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs, RNA</pre><p>Then load an example alignment of 20 phe-tRNA sequences which we will use to create the profile</p>
<pre class="code">&gt;&gt;&gt; aln = LoadSeqs(<span class="py_string">"data/trna_profile.fasta"</span>, moltype=RNA)</pre><p>Examine the number of sequences in the alignment and the alignment length</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> len(aln.Seqs)
20
&gt;&gt;&gt; <span class="py_keyword">print</span> len(aln)
77</pre><p>Create a profile containing the counts of each base at each alignment position</p>
<pre class="code">&gt;&gt;&gt; pf = aln.getPosFreqs()
&gt;&gt;&gt; <span class="py_keyword">print</span> pf.prettyPrint(include_header=<span class="py_keyword">True</span>)
U   C       A       G       -       B       D       H       K       M       N       S       R       W       V       Y       ?
0   0       0       20      0       0       0       0       0       0       0       0       0       0       0       0       0
0   12      0       8       0       0       0       0       0       0       0       0       0       0       0       0       0
1   18      0       1       0       0       0       0       0       0       0       0       0       0       0       0       0
7   9       0       4       0       0       0       0       0       0       0       0       0       0       0       0       0
...</pre><p>Normalize the positions to get the relative frequencies at each position</p>
<pre class="code">&gt;&gt;&gt; pf.normalizePositions()
&gt;&gt;&gt; <span class="py_keyword">print</span> pf.prettyPrint(include_header=<span class="py_keyword">True</span>)
U   C       A       G       -       B       D       H       K       M       N       S       R       W       V       Y       ?
0.0 0.0     0.0     1.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0
0.0 0.6     0.0     0.4     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0
0.05        0.9     0.0     0.05    0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0
0.35        0.45    0.0     0.2     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0
...</pre><p>Make sure the data in the profile is valid. The method isValid checks whether all rows add up to one and whether the profile has a valid Alphabet and CharacterOrder.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> pf.isValid()
<span class="py_keyword">True</span></pre><p>A profile can be used to calculate consensus sequences from the alignment. To illustrate the different options for consensus calculation, let's examine the frequency data at the fifth position of the alignment (index=4)</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> <span class="py_string">'\n'</span>.join([<span class="py_string">'%s: %.3f'</span>%(c,f) <span class="py_keyword">for</span> (c,f) <span class="py_keyword">in</span> zip(pf.CharOrder, pf.dataAt(4)) <span class="py_keyword">if</span> f!=0])
U: 0.050
C: 0.400
A: 0.250
G: 0.300</pre><p>The easiest consensus calculation will simply take the most frequent character at each position.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> pf.toConsensus(fully_degenerate=<span class="py_keyword">False</span>)
GCCCCGGUAGCUCAGU--GGUAGAGCAGGGGACUGAAAAUCCCCGUGUCGGCGGUUCGAUUCCGUCCCGGGGCACCA</pre><p>You can also specify to use the degenerate character needed to cover all symbols occurring at a certain alignment position (fully_degenerate=True). At index 4 in the alignment U, C, A, and G occur, thus the fully degenerate symbol needed is 'N'. Alternatively, using the cutoff value, you can ask for the degenerate symbol needed to cover a certain frequency. At a cutoff of 0.8, we need both C, G, and A at index 4 to cover this value, which results in the degenerate character 'V'. For the lower cutoff of 0.6, C and G suffice, and thus the character in the consensus sequence is 'S'.</p>
<pre class="code">&gt;&gt;&gt; pf.Alphabet=RNA
&gt;&gt;&gt; <span class="py_keyword">print</span> pf.toConsensus(fully_degenerate=<span class="py_keyword">True</span>)
GSBBNNDUAGCUCAGH??GGKAGAGCRBNVGRYUGAARAYCBNVNKGUCVBBDGWUCRAWHCHSNBHNNNVSC?CHM
&gt;&gt;&gt; <span class="py_keyword">print</span> pf.toConsensus(cutoff=0.8)
GSCYVBRUAGCUCAGU??GGUAGAGCASVSGAYUGAAAAUCYBSRUGUCSSYGGUUCGAUUCCGBSYSBRGSCACCA
&gt;&gt;&gt; <span class="py_keyword">print</span> pf.toConsensus(cutoff=0.6)
GCCYSGRUAGCUCAGU??GGUAGAGCAGRGGACUGAAAAUCCYCGUGUCGGYGGUUCGAUUCCGYCYCKRGGCACCA</pre><p>A profile could also function as the description of a certain motif. As an example, let's create a profile description for the T-pseudouridine-C-loop which starts at index 54 and ends at index 59 (based on the reference structure matching the alignment).</p>
<pre class="code">&gt;&gt;&gt; loop_profile = Profile(pf.Data[54:60,:], Alphabet=RNA, CharOrder=pf.CharOrder)
&gt;&gt;&gt; <span class="py_keyword">print</span> loop_profile.prettyPrint(include_header=<span class="py_keyword">True</span>)
U   C       A       G       -       B       D       H       K       M       N       S       R       W       V       Y       ?
0.95        0.0     0.05    0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0
1.0 0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0
0.0 1.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0
0.0 0.0     0.05    0.95    0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0
0.0 0.0     1.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0
0.85        0.0     0.15    0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0</pre><p>We can calculate how well this profile matches in a certain sequence (or profile) by using the score method. As an example we see where the loop profile best fits into the yeast phe-tRNA sequence. As expected, we find the best hit at index 54 (with a score of 5.75).</p>
<pre class="code">&gt;&gt;&gt; yeast = RNA.Sequence(<span class="py_string">'GCGGAUUUAGCUCAGUU-GGGAGAGCGCCAGACUGAAGAUCUGGAGGUCCUGUGUUCGAUCCACAGAAUUCGCACCA'</span>)
&gt;&gt;&gt; scores = loop_profile.score(yeast)
&gt;&gt;&gt; <span class="py_keyword">print</span> scores
[ 2.8   0.9   0.85  0.15  2.05  2.    3.75  0.95  1.2   1.    2.9   2.75
  0.    0.05  1.    2.9   2.05  1.95  0.2   1.95  0.05  1.    0.    2.
  0.15  2.    1.2   1.95  0.9   0.05  1.15  2.15  2.05  1.15  2.8   0.1
  0.9   0.    2.05  2.05  2.95  1.    1.8   0.95  0.05  0.85  2.    2.8
  0.95  1.85  2.75  1.    0.95  1.15  5.75  1.    0.    0.15  3.05  2.15
  1.    1.2   2.15  1.9   0.95  0.    0.05  1.05  4.05  1.95  1.05  0.15]
&gt;&gt;&gt; <span class="py_keyword">print</span> max(scores)
5.75
&gt;&gt;&gt; <span class="py_keyword">print</span> scores.argmax()
54</pre></div>
<div class="section">
<h2><a class="toc-backref" href="#id19" id="compute-the-effect-of-a-nucleotide-substitution-on-residue-polarity-in-two-different-genetic-codes-using-geneticcode-and-aaindex" name="compute-the-effect-of-a-nucleotide-substitution-on-residue-polarity-in-two-different-genetic-codes-using-geneticcode-and-aaindex">Compute the effect of a nucleotide substitution on residue polarity in two different genetic codes using GeneticCode and AAIndex</a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Greg Caporaso</td>
</tr>
</tbody>
</table>
<p>This document illustrates how to work with a genetic code object, and compare two different genetic codes. Here we compare the change in residue polarity, as judged by the Woese Polarity Requirement index (Woese 1973), resulting from a nucleotide substitution if the sequence is translated with the standard nuclear genetic code, or the vertebrate mitochondrial genetic code.</p>
<p>First, we load the genetic code objects and look at how they differ from one another.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.core.genetic_code <span class="py_keyword">import</span> GeneticCode
&gt;&gt;&gt; standard_nuclear_genetic_code = GeneticCode(<span class="py_string">'FFLLSSSSYY**CC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG'</span>)
&gt;&gt;&gt; vertebrate_mitochondrial_genetic_code = GeneticCode(<span class="py_string">'FFLLSSSSYY**CCWWLLLLPPPPHHQQRRRRIIMMTTTTNNKKSS**VVVVAAAADDEEGGGG'</span>)
&gt;&gt;&gt; standard_nuclear_genetic_code == vertebrate_mitochondrial_genetic_code
<span class="py_keyword">False</span>
&gt;&gt;&gt; differences = standard_nuclear_genetic_code.changes(vertebrate_mitochondrial_genetic_code).items()
&gt;&gt;&gt; differences.sort()
&gt;&gt;&gt; differences
[(<span class="py_string">'AGA'</span>, <span class="py_string">'R*'</span>), (<span class="py_string">'AGG'</span>, <span class="py_string">'R*'</span>), (<span class="py_string">'ATA'</span>, <span class="py_string">'IM'</span>), (<span class="py_string">'TGA'</span>, <span class="py_string">'*W'</span>)]</pre><p>We'll make some synonyms for the objects for simplicity:</p>
<pre class="code">&gt;&gt;&gt; ngc = standard_nuclear_genetic_code
&gt;&gt;&gt; mgc = vertebrate_mitochondrial_genetic_code</pre><p>Next, let's load the Woese Polar Requirement <tt class="docutils literal"><span class="pre">AAIndex</span></tt> data, and find the effect of an ATA to ATG substitution with each of the two <tt class="docutils literal"><span class="pre">GeneticCode</span></tt> objects.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.parse.aaindex <span class="py_keyword">import</span> getWoeseDistanceMatrix
&gt;&gt;&gt; woese_distance_matrix = getWoeseDistanceMatrix()
&gt;&gt;&gt; woese_distance_matrix[ngc[<span class="py_string">'ATA'</span>]][ngc[<span class="py_string">'ATG'</span>]]
0.39999999999999947
&gt;&gt;&gt; woese_distance_matrix[mgc[<span class="py_string">'ATA'</span>]][mgc[<span class="py_string">'ATG'</span>]]
0.0</pre><p>This illustrates that there is a difference in residue polarity associated with substitution only in the standard nuclear code (where ATA to ATG translates to an isoleucine to methionine substitution). In the vertebrate mitochondrial code, ATA to ATG is a synonymous substitution. Calculations of this type were central to <a class="footnote-reference" href="#id2" id="id1" name="id1">[1]</a> which presents the study that these modules were initially developed for.</p>
<p><tt class="docutils literal"><span class="pre">GeneticCode</span></tt> objects can also be used to translate DNA sequences (where asterisks in the results refer to stop-translation characters):</p>
<pre class="code">&gt;&gt;&gt; dna = <span class="py_string">"AAACGCTGTGTGTGAGATGAAAAA"</span>
&gt;&gt;&gt; ngc.translate(dna)
<span class="py_string">'KRCV*DEK'</span>
&gt;&gt;&gt; mgc.translate(dna)
<span class="py_string">'KRCVWDEK'</span></pre><p>The standard nuclear genetic code can also be loaded as <tt class="docutils literal"><span class="pre">DEFAULT</span></tt>:</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.core.genetic_code <span class="py_keyword">import</span> DEFAULT
&gt;&gt;&gt; DEFAULT == standard_nuclear_genetic_code
<span class="py_keyword">True</span></pre><p><strong>Citations</strong></p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id2">[1]</a></td><td>Caporaso, Yarus, and Knight. <em>Error minimization and coding triplet/binding site associations are independent features of the canonical genetic code.</em> J Mol Evol, 61(5):597-607, 2005.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id20" id="data-manipulation-using-table" name="data-manipulation-using-table">Data Manipulation using <tt class="docutils literal"><span class="pre">Table</span></tt></a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Gavin Huttley</td>
</tr>
<tr class="field"><th class="field-name">Copyright:</th><td class="field-body">Copyright 2007-2008, The Cogent Project</td>
</tr>
<tr class="field"><th class="field-name">Credits:</th><td class="field-body">Gavin Huttley, Felix Schill</td>
</tr>
<tr class="field"><th class="field-name">License:</th><td class="field-body">GPL</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">1.0.1</td>
</tr>
<tr class="field"><th class="field-name">Maintainer:</th><td class="field-body">Gavin Huttley</td>
</tr>
<tr class="field"><th class="field-name">Email:</th><td class="field-body"><a class="reference" href="mailto:gavin.huttley&#64;anu.edu.au">gavin.huttley&#64;anu.edu.au</a></td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Production</td>
</tr>
</tbody>
</table>
<p>The toolkit has a <tt class="docutils literal"><span class="pre">Table</span></tt> object that can be used for manipulating tabular data. It's properties can be considered like an ordered 2 dimensional dictionary or tuple with flexible output format capabilities of use for exporting statistics for import into external applications. Importantly, via the restructured text format one can generate html or latex formatted tables. The table module is located within <tt class="docutils literal"><span class="pre">cogent.format</span></tt>.</p>
<div class="section">
<h3><a class="toc-backref" href="#id21" id="testing-a-sub-component" name="testing-a-sub-component">Testing a sub-component</a></h3>
<p>Before using <tt class="docutils literal"><span class="pre">Table</span></tt>, we exercise some formatting code:</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.format.table <span class="py_keyword">import</span> formattedCells, drawToPDF, phylipMatrix
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.format.table <span class="py_keyword">import</span> latex</pre><p>Of interest to be able to format an arbitrary 2D list, without a header. We use the <tt class="docutils literal"><span class="pre">formattedCells</span></tt> function directly. We allow for the case that <tt class="docutils literal"><span class="pre">reportlab</span></tt> may not be present.</p>
<pre class="code">&gt;&gt;&gt; data = [[230, <span class="py_string">'acdef'</span>, 1.3], [6, <span class="py_string">'cc'</span>, 1.9876]]
&gt;&gt;&gt; header, formatted = formattedCells(data, header = [<span class="py_string">'one'</span>, <span class="py_string">'two'</span>,
...  <span class="py_string">'three'</span>])
&gt;&gt;&gt; <span class="py_keyword">print</span> formatted
[[<span class="py_string">'230'</span>, <span class="py_string">'acdef'</span>, <span class="py_string">'1.3000'</span>], [<span class="py_string">'  6'</span>, <span class="py_string">'   cc'</span>, <span class="py_string">'1.9876'</span>]]
&gt;&gt;&gt; <span class="py_keyword">print</span> header
[<span class="py_string">'one'</span>, <span class="py_string">'  two'</span>, <span class="py_string">' three'</span>]
&gt;&gt;&gt; <span class="py_keyword">try</span>:
...     drawToPDF([<span class="py_string">'one'</span>, <span class="py_string">'two'</span>, <span class="py_string">'three'</span>], formatted, <span class="py_string">"junk.pdf"</span>)
... <span class="py_keyword">except</span> ImportError:
...     <span class="py_keyword">pass</span></pre><p>We directly test the latex formatting.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> latex(formatted, header, justify=<span class="py_string">'lrl'</span>, caption=<span class="py_string">'A legend'</span>,
...             label=<span class="py_string">"table:test"</span>)
\begin{longtable}[htp!]{ l r l }
\hline
\bf{one} &amp; \bf{two} &amp; \bf{three} \\
\hline
\hline
230 &amp; acdef &amp; 1.3000 \\
  6 &amp;    cc &amp; 1.9876 \\
\hline
\caption{A legend}
\label{table:test}
\end{longtable}</pre></div>
<div class="section">
<h3><a class="toc-backref" href="#id22" id="table-creation" name="table-creation">Table creation</a></h3>
<p>Tables can be created directly using the Table object itself, or a convenience function that handles loading from files. We import both here:</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadTable
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.util.table <span class="py_keyword">import</span> Table</pre><p>Let's create a very simple, rather nonsensical, table first. To create a table requires a header series, and a 2D series (either of type <tt class="docutils literal"><span class="pre">tuple</span></tt>, <tt class="docutils literal"><span class="pre">list</span></tt>, <tt class="docutils literal"><span class="pre">dict</span></tt>).</p>
<pre class="code">&gt;&gt;&gt; column_headings = [<span class="py_string">'Journal'</span>, <span class="py_string">'Impact'</span>]</pre><p>The string &quot;Journal&quot; will become the first column heading, &quot;Impact&quot; the second column heading. The data are,</p>
<pre class="code">&gt;&gt;&gt; rows = [[<span class="py_string">'INT J PARASITOL'</span>, 2.9],
... [<span class="py_string">'J MED ENTOMOL'</span>, 1.4],
... [<span class="py_string">'Med Vet Entomol'</span>, 1.0],
... [<span class="py_string">'INSECT MOL BIOL'</span>, 2.85],
... [<span class="py_string">'J AM MOSQUITO CONTR'</span>, 0.811],
... [<span class="py_string">'MOL PHYLOGENET EVOL'</span>, 2.8],
... [<span class="py_string">'HEREDITY'</span>, 1.99e+0],
... [<span class="py_string">'AM J TROP MED HYG'</span>, 2.105],
... [<span class="py_string">'MIL MED'</span>, 0.605],
... [<span class="py_string">'MED J AUSTRALIA'</span>, 1.736]]</pre><p>We create the simplest of tables.</p>
<pre class="code">&gt;&gt;&gt; t = Table(header = column_headings, rows = rows)
&gt;&gt;&gt; <span class="py_keyword">print</span> t
=============================
            Journal    Impact
-----------------------------
    INT J PARASITOL    2.9000
      J MED ENTOMOL    1.4000
    Med Vet Entomol    1.0000
    INSECT MOL BIOL    2.8500
J AM MOSQUITO CONTR    0.8110
MOL PHYLOGENET EVOL    2.8000
           HEREDITY    1.9900
  AM J TROP MED HYG    2.1050
            MIL MED    0.6050
    MED J AUSTRALIA    1.7360
-----------------------------</pre><p>The format above is referred to as 'simple' format in the documentation. Notice that the numbers in this table have 4 decimal places, despite the fact the original data were largely strings and had <tt class="docutils literal"><span class="pre">max</span></tt> of 3 decimal places precision. <tt class="docutils literal"><span class="pre">Table</span></tt> converts string representations of numbers to their appropriate form when you do <tt class="docutils literal"><span class="pre">str(table)</span></tt> or print the table.</p>
<p>We have several things we might want to specify when creating a table: the precision and or format of floating point numbers (integer argument - <tt class="docutils literal"><span class="pre">digits</span></tt>), the spacing between columns (integer argument or actual string of whitespace - <tt class="docutils literal"><span class="pre">space</span></tt>), title (argument - <tt class="docutils literal"><span class="pre">title</span></tt>), and legend (argument - <tt class="docutils literal"><span class="pre">legend</span></tt>). Lets modify some of these and provide a title and legend.</p>
<pre class="code">&gt;&gt;&gt; t = Table(column_headings, rows, title=<span class="py_string">'Journal impact factors'</span>, legend=<span class="py_string">'From ISI'</span>,
... digits=2, space=<span class="py_string">'        '</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> t
Journal impact factors
=================================
            Journal        Impact
---------------------------------
    INT J PARASITOL          2.90
      J MED ENTOMOL          1.40
    Med Vet Entomol          1.00
    INSECT MOL BIOL          2.85
J AM MOSQUITO CONTR          0.81
MOL PHYLOGENET EVOL          2.80
           HEREDITY          1.99
  AM J TROP MED HYG          2.10
            MIL MED          0.60
    MED J AUSTRALIA          1.74
---------------------------------
From ISI</pre><p>The Table class cannot handle arbitrary python objects, unless they are passed in as strings. Note in this case we now directly pass in the column headings list and the handling of missing data can be explicitly specified..</p>
<pre class="code">&gt;&gt;&gt; t2 = Table([<span class="py_string">'abcd'</span>, <span class="py_string">'data'</span>], [[str(range(1,6)), <span class="py_string">'0'</span>],
...                               [<span class="py_string">'x'</span>, 5.0], [<span class="py_string">'y'</span>, <span class="py_keyword">None</span>]],
...           missing_data=<span class="py_string">'*'</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> t2
=========================
           abcd      data
-------------------------
[1, 2, 3, 4, 5]         0
              x    5.0000
              y         *
-------------------------</pre><p>Tables may also be created from 2-dimensional dictionaries. In this case, special capabilities are provided to enforce printing rows in a particular order.</p>
<pre class="code">&gt;&gt;&gt; d2D={<span class="py_string">'edge.parent'</span>: {<span class="py_string">'NineBande'</span>: <span class="py_string">'root'</span>, <span class="py_string">'edge.1'</span>: <span class="py_string">'root'</span>,
... <span class="py_string">'DogFaced'</span>: <span class="py_string">'root'</span>, <span class="py_string">'Human'</span>: <span class="py_string">'edge.0'</span>, <span class="py_string">'edge.0'</span>: <span class="py_string">'edge.1'</span>,
... <span class="py_string">'Mouse'</span>: <span class="py_string">'edge.1'</span>, <span class="py_string">'HowlerMon'</span>: <span class="py_string">'edge.0'</span>}, <span class="py_string">'x'</span>: {<span class="py_string">'NineBande'</span>: 1.0,
... <span class="py_string">'edge.1'</span>: 1.0, <span class="py_string">'DogFaced'</span>: 1.0, <span class="py_string">'Human'</span>: 1.0, <span class="py_string">'edge.0'</span>: 1.0,
... <span class="py_string">'Mouse'</span>: 1.0, <span class="py_string">'HowlerMon'</span>: 1.0}, <span class="py_string">'length'</span>: {<span class="py_string">'NineBande'</span>: 4.0,
... <span class="py_string">'edge.1'</span>: 4.0, <span class="py_string">'DogFaced'</span>: 4.0, <span class="py_string">'Human'</span>: 4.0, <span class="py_string">'edge.0'</span>: 4.0,
... <span class="py_string">'Mouse'</span>: 4.0, <span class="py_string">'HowlerMon'</span>: 4.0}, <span class="py_string">'y'</span>: {<span class="py_string">'NineBande'</span>: 3.0, <span class="py_string">'edge.1'</span>: 3.0,
... <span class="py_string">'DogFaced'</span>: 3.0, <span class="py_string">'Human'</span>: 3.0, <span class="py_string">'edge.0'</span>: 3.0, <span class="py_string">'Mouse'</span>: 3.0,
... <span class="py_string">'HowlerMon'</span>: 3.0}, <span class="py_string">'z'</span>: {<span class="py_string">'NineBande'</span>: 6.0, <span class="py_string">'edge.1'</span>: 6.0,
... <span class="py_string">'DogFaced'</span>: 6.0, <span class="py_string">'Human'</span>: 6.0, <span class="py_string">'edge.0'</span>: 6.0, <span class="py_string">'Mouse'</span>: 6.0,
... <span class="py_string">'HowlerMon'</span>: 6.0},
... <span class="py_string">'edge.name'</span>: [<span class="py_string">'Human'</span>, <span class="py_string">'HowlerMon'</span>, <span class="py_string">'Mouse'</span>, <span class="py_string">'NineBande'</span>, <span class="py_string">'DogFaced'</span>,
... <span class="py_string">'edge.0'</span>, <span class="py_string">'edge.1'</span>]}
&gt;&gt;&gt; row_order = d2D[<span class="py_string">'edge.name'</span>]
&gt;&gt;&gt; d2D[<span class="py_string">'edge.name'</span>] = dict(zip(row_order, row_order))
&gt;&gt;&gt; t3 = Table([<span class="py_string">'edge.name'</span>, <span class="py_string">'edge.parent'</span>, <span class="py_string">'length'</span>, <span class="py_string">'x'</span>, <span class="py_string">'y'</span>, <span class="py_string">'z'</span>], d2D,
... row_order = row_order, missing_data=<span class="py_string">'*'</span>, space=8, max_width = 50,
... row_ids = <span class="py_keyword">True</span>, title = <span class="py_string">'My Title'</span>,
... legend = <span class="py_string">'Legend: this is a nonsense example.'</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> t3
My Title
==========================================
edge.name        edge.parent        length
------------------------------------------
    Human             edge.0        4.0000
HowlerMon             edge.0        4.0000
    Mouse             edge.1        4.0000
NineBande               root        4.0000
 DogFaced               root        4.0000
   edge.0             edge.1        4.0000
   edge.1               root        4.0000
------------------------------------------

continued: My Title
=====================================
edge.name             x             y
-------------------------------------
    Human        1.0000        3.0000
HowlerMon        1.0000        3.0000
    Mouse        1.0000        3.0000
NineBande        1.0000        3.0000
 DogFaced        1.0000        3.0000
   edge.0        1.0000        3.0000
   edge.1        1.0000        3.0000
-------------------------------------

continued: My Title
=======================
edge.name             z
-----------------------
    Human        6.0000
HowlerMon        6.0000
    Mouse        6.0000
NineBande        6.0000
 DogFaced        6.0000
   edge.0        6.0000
   edge.1        6.0000
-----------------------

Legend: this <span class="py_keyword">is</span> a nonsense example.</pre><p>In the above we specify a maximum width of the table, and also specify row identifiers (using <tt class="docutils literal"><span class="pre">row_ids</span></tt>, the integer corresponding to the column at which data begin, preceding columns are taken as the identifiers). This has the effect of forcing the table to wrap when the simple text format is used, but wrapping does not occur for any other format. The <tt class="docutils literal"><span class="pre">row_ids</span></tt> are keys for slicing the table by row, and as identifiers are presented in each wrapped sub-table.</p>
<p>We can also customise the formatting of individual columns.</p>
<pre class="code">&gt;&gt;&gt; rows = ((<span class="py_string">'NP_003077_hs_mm_rn_dna'</span>, <span class="py_string">'Con'</span>, 2.5386013224378985),
... (<span class="py_string">'NP_004893_hs_mm_rn_dna'</span>, <span class="py_string">'Con'</span>, 0.12135142635634111e+06),
... (<span class="py_string">'NP_005079_hs_mm_rn_dna'</span>, <span class="py_string">'Con'</span>, 0.95165949788861326e+07),
... (<span class="py_string">'NP_005500_hs_mm_rn_dna'</span>, <span class="py_string">'Con'</span>, 0.73827030202664901e-07),
... (<span class="py_string">'NP_055852_hs_mm_rn_dna'</span>, <span class="py_string">'Con'</span>, 1.0933217708952725e+07))</pre><p>We first create a table and show the default formatting behaviour for <tt class="docutils literal"><span class="pre">Table</span></tt>.</p>
<pre class="code">&gt;&gt;&gt; t46 = Table([<span class="py_string">'Gene'</span>, <span class="py_string">'Type'</span>, <span class="py_string">'LR'</span>], rows)
&gt;&gt;&gt; <span class="py_keyword">print</span> t46
===============================================
                  Gene    Type               LR
-----------------------------------------------
NP_003077_hs_mm_rn_dna     Con           2.5386
NP_004893_hs_mm_rn_dna     Con      121351.4264
NP_005079_hs_mm_rn_dna     Con     9516594.9789
NP_005500_hs_mm_rn_dna     Con           0.0000
NP_055852_hs_mm_rn_dna     Con    10933217.7090
-----------------------------------------------</pre><p>We then format the <tt class="docutils literal"><span class="pre">LR</span></tt> column to use a scientific number format.</p>
<pre class="code">&gt;&gt;&gt; t46 = Table([<span class="py_string">'Gene'</span>, <span class="py_string">'Type'</span>, <span class="py_string">'LR'</span>], rows)
&gt;&gt;&gt; t46.setColumnFormat(<span class="py_string">'LR'</span>, <span class="py_string">"%.4e"</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> t46
============================================
                  Gene    Type            LR
--------------------------------------------
NP_003077_hs_mm_rn_dna     Con    2.5386e+00
NP_004893_hs_mm_rn_dna     Con    1.2135e+05
NP_005079_hs_mm_rn_dna     Con    9.5166e+06
NP_005500_hs_mm_rn_dna     Con    7.3827e-08
NP_055852_hs_mm_rn_dna     Con    1.0933e+07
--------------------------------------------</pre><p>It is safe to directly modify certain attributes, such as the title, legend and white space separating columns, which we do for the <tt class="docutils literal"><span class="pre">t46</span></tt>.</p>
<pre class="code">&gt;&gt;&gt; t46.Title = <span class="py_string">"A new title"</span>
&gt;&gt;&gt; t46.Legend = <span class="py_string">"A new legend"</span>
&gt;&gt;&gt; t46.Space = <span class="py_string">'  '</span>
&gt;&gt;&gt; <span class="py_keyword">print</span> t46
A new title
========================================
                  Gene  Type          LR
----------------------------------------
NP_003077_hs_mm_rn_dna   Con  2.5386e+00
NP_004893_hs_mm_rn_dna   Con  1.2135e+05
NP_005079_hs_mm_rn_dna   Con  9.5166e+06
NP_005500_hs_mm_rn_dna   Con  7.3827e-08
NP_055852_hs_mm_rn_dna   Con  1.0933e+07
----------------------------------------
A new legend</pre><p>We can provide settings for multiple columns.</p>
<pre class="code">&gt;&gt;&gt; t3 = Table([<span class="py_string">'edge.name'</span>, <span class="py_string">'edge.parent'</span>, <span class="py_string">'length'</span>, <span class="py_string">'x'</span>, <span class="py_string">'y'</span>, <span class="py_string">'z'</span>], d2D,
... row_order = row_order)
&gt;&gt;&gt; t3.setColumnFormat(<span class="py_string">'x'</span>, <span class="py_string">"%.1e"</span>)
&gt;&gt;&gt; t3.setColumnFormat(<span class="py_string">'y'</span>, <span class="py_string">"%.2f"</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> t3
===============================================================
edge.name    edge.parent    length          x       y         z
---------------------------------------------------------------
    Human         edge.0    4.0000    1.0e+00    3.00    6.0000
HowlerMon         edge.0    4.0000    1.0e+00    3.00    6.0000
    Mouse         edge.1    4.0000    1.0e+00    3.00    6.0000
NineBande           root    4.0000    1.0e+00    3.00    6.0000
 DogFaced           root    4.0000    1.0e+00    3.00    6.0000
   edge.0         edge.1    4.0000    1.0e+00    3.00    6.0000
   edge.1           root    4.0000    1.0e+00    3.00    6.0000
---------------------------------------------------------------</pre><p>In some cases, the contents of a column can be of different types. In this instance, rather than passing a column template we pass a reference to a function that will handle this complexity. To illustrate this we will define a function that formats floating point numbers, but returns everything else as is.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">def</span> <span class="py_identifier">formatcol</span>(value):
...     <span class="py_keyword">if</span> isinstance(value, float):
...         val = <span class="py_string">"%.2f"</span> % value
...     <span class="py_keyword">else</span>:
...         val = str(value)
...     <span class="py_keyword">return</span> val</pre><p>We apply this to a table with mixed string, integer and floating point data.</p>
<pre class="code">&gt;&gt;&gt; t6 = Table([<span class="py_string">'ColHead'</span>], [[<span class="py_string">'a'</span>], [1], [0.3], [<span class="py_string">'cc'</span>]],
... column_templates = dict(ColHead=formatcol))
&gt;&gt;&gt; <span class="py_keyword">print</span> t6
=======
ColHead
-------
      a
      1
   0.30
     cc
-------</pre></div>
<div class="section">
<h3><a class="toc-backref" href="#id23" id="table-output" name="table-output">Table output</a></h3>
<p>Other formats are also possible, including restructured text or 'rest' and delimited. These can be obtained using the <tt class="docutils literal"><span class="pre">tostring</span></tt> method and <tt class="docutils literal"><span class="pre">format</span></tt> argument as follows. Using table <tt class="docutils literal"><span class="pre">t</span></tt> from above,</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> t.tostring(format=<span class="py_string">'rest'</span>)
+------------------------------+
|    Journal impact factors    |
+---------------------+--------+
|             Journal | Impact |
+=====================+========+
|     INT J PARASITOL |   2.90 |
+---------------------+--------+
|       J MED ENTOMOL |   1.40 |
+---------------------+--------+
|     Med Vet Entomol |   1.00 |
+---------------------+--------+
|     INSECT MOL BIOL |   2.85 |
+---------------------+--------+
| J AM MOSQUITO CONTR |   0.81 |
+---------------------+--------+
| MOL PHYLOGENET EVOL |   2.80 |
+---------------------+--------+
|            HEREDITY |   1.99 |
+---------------------+--------+
|   AM J TROP MED HYG |   2.10 |
+---------------------+--------+
|             MIL MED |   0.60 |
+---------------------+--------+
|     MED J AUSTRALIA |   1.74 |
+---------------------+--------+
| From ISI                     |
+------------------------------+</pre><p>Arguments such as <tt class="docutils literal"><span class="pre">space</span></tt> have no effect in this case. The table may also be written to file in any of the available formats (latex, simple text, html, pickle) or using a custom separator (such as a comma or tab). This makes it convenient to get data into other applications (such as R or excel).</p>
<p>Here is the latex format, note how the title and legend are joined into the latex table caption. We also provide optional arguments for the column alignment (fist column left aligned, second column right aligned and remaining columns centred) and a label for table referencing.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> t3.tostring(format=<span class="py_string">'tex'</span>, justify=<span class="py_string">"lrcccc"</span>, label=<span class="py_string">"table:example"</span>)
\begin{longtable}[htp!]{ l r c c c c }
\hline
\bf{edge.name} &amp; \bf{edge.parent} &amp; \bf{length} &amp; \bf{x} &amp; \bf{y} &amp; \bf{z} \\
\hline
\hline
    Human &amp;      edge.0 &amp; 4.0000 &amp; 1.0e+00 &amp; 3.00 &amp; 6.0000 \\
HowlerMon &amp;      edge.0 &amp; 4.0000 &amp; 1.0e+00 &amp; 3.00 &amp; 6.0000 \\
    Mouse &amp;      edge.1 &amp; 4.0000 &amp; 1.0e+00 &amp; 3.00 &amp; 6.0000 \\
NineBande &amp;        root &amp; 4.0000 &amp; 1.0e+00 &amp; 3.00 &amp; 6.0000 \\
 DogFaced &amp;        root &amp; 4.0000 &amp; 1.0e+00 &amp; 3.00 &amp; 6.0000 \\
   edge.0 &amp;      edge.1 &amp; 4.0000 &amp; 1.0e+00 &amp; 3.00 &amp; 6.0000 \\
   edge.1 &amp;        root &amp; 4.0000 &amp; 1.0e+00 &amp; 3.00 &amp; 6.0000 \\
\hline
\label{table:example}
\end{longtable}</pre><p>More complex latex table justifying is also possible. Specifying the width of individual columns requires passing in a series (list or tuple) of justification commands. In the following we introduce the command for specific columns widths.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> t3.tostring(format=<span class="py_string">'tex'</span>, justify=[<span class="py_string">"l"</span>,<span class="py_string">"p{3cm}"</span>,<span class="py_string">"c"</span>,<span class="py_string">"c"</span>,<span class="py_string">"c"</span>,<span class="py_string">"c"</span>])
\begin{longtable}[htp!]{ l p{3cm} c c c c }
\hline
\bf{edge.name} &amp; \bf{edge.parent} &amp; \bf{length} &amp; \bf{x} &amp; \bf{y} &amp; \bf{z} \\
\hline
\hline
    Human &amp;      edge.0 &amp; 4.0000 &amp; 1.0e+00 &amp; 3.00 &amp; 6.0000 \\
HowlerMon &amp;      edge.0 &amp; 4.0000 &amp; 1.0e+00 &amp; 3.00 &amp; 6.0000 \\
    Mouse &amp;      edge.1 &amp; 4.0000 &amp; 1.0e+00 &amp; 3.00 &amp; 6.0000 \\
NineBande &amp;        root &amp; 4.0000 &amp; 1.0e+00 &amp; 3.00 &amp; 6.0000 \\
 DogFaced &amp;        root &amp; 4.0000 &amp; 1.0e+00 &amp; 3.00 &amp; 6.0000 \\
   edge.0 &amp;      edge.1 &amp; 4.0000 &amp; 1.0e+00 &amp; 3.00 &amp; 6.0000 \\
   edge.1 &amp;        root &amp; 4.0000 &amp; 1.0e+00 &amp; 3.00 &amp; 6.0000 \\
\hline
\end{longtable}
&gt;&gt;&gt; <span class="py_keyword">print</span> t3.tostring(sep=<span class="py_string">','</span>)
edge.name,edge.parent,length,      x,   y,     z
    Human,     edge.0,4.0000,1.0e+00,3.00,6.0000
HowlerMon,     edge.0,4.0000,1.0e+00,3.00,6.0000
    Mouse,     edge.1,4.0000,1.0e+00,3.00,6.0000
NineBande,       root,4.0000,1.0e+00,3.00,6.0000
 DogFaced,       root,4.0000,1.0e+00,3.00,6.0000
   edge.0,     edge.1,4.0000,1.0e+00,3.00,6.0000
   edge.1,       root,4.0000,1.0e+00,3.00,6.0000</pre><p>You can specify any standard text character that will work with your desired target. Useful separators are tabs ('\t'), or pipes ('|'). If <tt class="docutils literal"><span class="pre">Table</span></tt> encounters any of these characters within a cell, it wraps the cell in quotes -- a standard approach to facilitate import by other applications. We will illustrate this with <tt class="docutils literal"><span class="pre">t2</span></tt>.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> t2.tostring(sep=<span class="py_string">', '</span>)
           abcd,   data
<span class="py_string">"[1, 2, 3, 4, 5]"</span>,      0
              x, 5.0000
              y,      *</pre><p>Note that I introduced an extra space after the column just to make the result more readable in this example.</p>
<p>Test the writing of phylip distance matrix format.</p>
<pre class="code">&gt;&gt;&gt; rows = [[<span class="py_string">'a'</span>, <span class="py_string">''</span>, 0.088337278874079342, 0.18848582712597683,
...  0.44084000179091454], [<span class="py_string">'c'</span>, 0.088337278874079342, <span class="py_string">''</span>,
...  0.088337278874079342, 0.44083999937417828], [<span class="py_string">'b'</span>, 0.18848582712597683,
...  0.088337278874079342, <span class="py_string">''</span>, 0.44084000179090932], [<span class="py_string">'e'</span>,
...  0.44084000179091454, 0.44083999937417828, 0.44084000179090932, <span class="py_string">''</span>]]
&gt;&gt;&gt; dist = Table(rows = rows, header = [<span class="py_string">'seq1/2'</span>, <span class="py_string">'a'</span>, <span class="py_string">'c'</span>, <span class="py_string">'b'</span>, <span class="py_string">'e'</span>],
...  row_ids = <span class="py_keyword">True</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> dist.tostring(format = <span class="py_string">'phylip'</span>)
   4
a           0.0000  0.0883  0.1885  0.4408
c           0.0883  0.0000  0.0883  0.4408
b           0.1885  0.0883  0.0000  0.4408
e           0.4408  0.4408  0.4408  0.0000</pre></div>
<div class="section">
<h3><a class="toc-backref" href="#id24" id="saving-a-table-for-reloading" name="saving-a-table-for-reloading">Saving a table for reloading</a></h3>
<p>Saving a table object to file for later reloading can be done using the standard <tt class="docutils literal"><span class="pre">writeToFile</span></tt> method and <tt class="docutils literal"><span class="pre">filename</span></tt> argument to the <tt class="docutils literal"><span class="pre">Table</span></tt> constructor and either the <tt class="docutils literal"><span class="pre">pickle</span></tt> or a delimited format (eg ',', '|'). The <tt class="docutils literal"><span class="pre">writeToFile</span></tt> saves the raw data in the appropriate format, the constructor recreates a table from raw data located at <tt class="docutils literal"><span class="pre">filename</span></tt>. We first write out the table <tt class="docutils literal"><span class="pre">t3</span></tt> in <tt class="docutils literal"><span class="pre">pickle</span></tt> format and then the table <tt class="docutils literal"><span class="pre">t2</span></tt> in a csv (comma separated values format).</p>
<pre class="code">&gt;&gt;&gt; t3 = Table([<span class="py_string">'edge.name'</span>, <span class="py_string">'edge.parent'</span>, <span class="py_string">'length'</span>, <span class="py_string">'x'</span>, <span class="py_string">'y'</span>, <span class="py_string">'z'</span>], d2D,
... row_order = row_order, missing_data=<span class="py_string">'*'</span>, space=8, max_width = 50,
... row_ids = <span class="py_keyword">True</span>, title = <span class="py_string">'My Title'</span>,
... legend = <span class="py_string">'Legend: this is a nonsense example.'</span>)
&gt;&gt;&gt; t3.writeToFile(<span class="py_string">"t3.pickle"</span>)
&gt;&gt;&gt; t3_loaded = LoadTable(filename = <span class="py_string">"t3.pickle"</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> t3_loaded
My Title
==========================================
edge.name        edge.parent        length
------------------------------------------
    Human             edge.0        4.0000
HowlerMon             edge.0        4.0000
    Mouse             edge.1        4.0000
NineBande               root        4.0000
 DogFaced               root        4.0000
   edge.0             edge.1        4.0000
   edge.1               root        4.0000
------------------------------------------

continued: My Title
=====================================
edge.name             x             y
-------------------------------------
    Human        1.0000        3.0000
HowlerMon        1.0000        3.0000
    Mouse        1.0000        3.0000
NineBande        1.0000        3.0000
 DogFaced        1.0000        3.0000
   edge.0        1.0000        3.0000
   edge.1        1.0000        3.0000
-------------------------------------

continued: My Title
=======================
edge.name             z
-----------------------
    Human        6.0000
HowlerMon        6.0000
    Mouse        6.0000
NineBande        6.0000
 DogFaced        6.0000
   edge.0        6.0000
   edge.1        6.0000
-----------------------

Legend: this <span class="py_keyword">is</span> a nonsense example.
&gt;&gt;&gt; t2 = Table([<span class="py_string">'abcd'</span>, <span class="py_string">'data'</span>], [[str(range(1,6)), <span class="py_string">'0'</span>], [<span class="py_string">'x'</span>, 5.0],
... [<span class="py_string">'y'</span>, <span class="py_keyword">None</span>]], missing_data=<span class="py_string">'*'</span>, title = <span class="py_string">'A \ntitle'</span>)
&gt;&gt;&gt; t2.writeToFile(<span class="py_string">'t2.csv'</span>, sep=<span class="py_string">','</span>)
&gt;&gt;&gt; t2_loaded = LoadTable(filename = <span class="py_string">'t2.csv'</span>, header = <span class="py_keyword">True</span>, with_title = <span class="py_keyword">True</span>,
...  sep = <span class="py_string">','</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> t2_loaded
A
title
=========================
           abcd      data
-------------------------
[1, 2, 3, 4, 5]         0
              x    5.0000
              y
-------------------------</pre><p>Note the <tt class="docutils literal"><span class="pre">missing_data</span></tt> attribute is not saved in the delimited format, but is in the <tt class="docutils literal"><span class="pre">pickle</span></tt> format. In the next case, I'm going to override the digits format on reloading of the table.</p>
<pre class="code">&gt;&gt;&gt; t2 = Table([<span class="py_string">'abcd'</span>, <span class="py_string">'data'</span>], [[str(range(1,6)), <span class="py_string">'0'</span>], [<span class="py_string">'x'</span>, 5.0],
... [<span class="py_string">'y'</span>, <span class="py_keyword">None</span>]], missing_data=<span class="py_string">'*'</span>, title = <span class="py_string">'A \ntitle'</span>,
... legend = <span class="py_string">"And\na legend too"</span>)
&gt;&gt;&gt; t2.writeToFile(<span class="py_string">'t2.csv'</span>, sep=<span class="py_string">','</span>)
&gt;&gt;&gt; t2_loaded = LoadTable(filename = <span class="py_string">'t2.csv'</span>, header = <span class="py_keyword">True</span>,
... with_title = <span class="py_keyword">True</span>, with_legend = <span class="py_keyword">True</span>, sep = <span class="py_string">','</span>, digits = 2)
&gt;&gt;&gt; <span class="py_keyword">print</span> t2_loaded
A
title
=======================
           abcd    data
-----------------------
[1, 2, 3, 4, 5]       0
              x    5.00
              y
-----------------------
And
a legend too</pre><p>A few things to note about the delimited file saving: formatting arguments are lost in saving to a delimited format; the <tt class="docutils literal"><span class="pre">header</span></tt> argument specifies whether the first line of file should be treated as the header; the <tt class="docutils literal"><span class="pre">with_title</span></tt> and <tt class="docutils literal"><span class="pre">with_legend</span></tt> arguments are necessary if the file contains them, otherwise the become the header or part of the file. Importantly, if you wish to preserve numerical precision use the <tt class="docutils literal"><span class="pre">pickle</span></tt> format.</p>
<p>cPickle should be able to load a useful object from the pickled Table alone.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">import</span> cPickle
&gt;&gt;&gt; f = file(<span class="py_string">"t3.pickle"</span>)
&gt;&gt;&gt; pickled = cPickle.load(f)
&gt;&gt;&gt; f.close()
&gt;&gt;&gt; pickled.keys()
[<span class="py_string">'digits'</span>, <span class="py_string">'row_ids'</span>, <span class="py_string">'rows'</span>, <span class="py_string">'title'</span>, <span class="py_string">'space'</span>, <span class="py_string">'max_width'</span>, <span class="py_string">'header'</span>, <span class="py_string">'missing_data'</span>, <span class="py_string">'legend'</span>]
&gt;&gt;&gt; pickled[<span class="py_string">'rows'</span>][0]
[<span class="py_string">'Human'</span>, <span class="py_string">'edge.0'</span>, 4.0, 1.0, 3.0, 6.0]</pre><p>We can read in a delimited format using a custom reader, which we'll now import. We convert columns 2-5 to floats by specifying a field convertor. We then create a reader, specifying the data (below a list but can be a file) properties. Note that if no convertor is provided all data are returned as strings. We can also provide this reader to the <tt class="docutils literal"><span class="pre">Table</span></tt> constructor for a more direct way of opening such files. In this case, <tt class="docutils literal"><span class="pre">Table</span></tt> assumes there is a header row and nothing else.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.parse.table <span class="py_keyword">import</span> ConvertFields, SeparatorFormatParser
&gt;&gt;&gt; t3.Title = t3.Legend = <span class="py_keyword">None</span>
&gt;&gt;&gt; comma_sep = t3.tostring(sep=<span class="py_string">","</span>).splitlines()
&gt;&gt;&gt; <span class="py_keyword">print</span> comma_sep
[<span class="py_string">'edge.name,edge.parent,length,     x,     y,     z'</span>, <span class="py_string">'    Human,     edge.0,4.0000,1.0000,3.0000,6.0000'</span>, <span class="py_string">'HowlerMon,     edge.0,4.0000,1.0000,3.0000,6.0000'</span>, <span class="py_string">'    Mouse,     edge.1,4.0000,1.0000,3.0000,6.0000'</span>, <span class="py_string">'NineBande,       root,4.0000,1.0000,3.0000,6.0000'</span>, <span class="py_string">' DogFaced,       root,4.0000,1.0000,3.0000,6.0000'</span>, <span class="py_string">'   edge.0,     edge.1,4.0000,1.0000,3.0000,6.0000'</span>, <span class="py_string">'   edge.1,       root,4.0000,1.0000,3.0000,6.0000'</span>]
&gt;&gt;&gt; converter = ConvertFields([(2,float), (3,float), (4,float), (5, float)])
&gt;&gt;&gt; reader = SeparatorFormatParser(with_header=<span class="py_keyword">True</span>,converter=converter,
...      sep=<span class="py_string">","</span>)
&gt;&gt;&gt; comma_sep = [line <span class="py_keyword">for</span> line <span class="py_keyword">in</span> reader(comma_sep)]
&gt;&gt;&gt; <span class="py_keyword">print</span> comma_sep
[[<span class="py_string">'edge.name'</span>, <span class="py_string">'edge.parent'</span>, <span class="py_string">'length'</span>, <span class="py_string">'x'</span>, <span class="py_string">'y'</span>, <span class="py_string">'z'</span>], [<span class="py_string">'Human'</span>, <span class="py_string">'edge.0'</span>, 4.0, 1.0, 3.0, 6.0], [<span class="py_string">'HowlerMon'</span>, <span class="py_string">'edge.0'</span>, 4.0, 1.0, 3.0, 6.0], [<span class="py_string">'Mouse'</span>, <span class="py_string">'edge.1'</span>, 4.0, 1.0, 3.0, 6.0], [<span class="py_string">'NineBande'</span>, <span class="py_string">'root'</span>, 4.0, 1.0, 3.0, 6.0], [<span class="py_string">'DogFaced'</span>, <span class="py_string">'root'</span>, 4.0, 1.0, 3.0, 6.0], [<span class="py_string">'edge.0'</span>, <span class="py_string">'edge.1'</span>, 4.0, 1.0, 3.0, 6.0], [<span class="py_string">'edge.1'</span>, <span class="py_string">'root'</span>, 4.0, 1.0, 3.0, 6.0]]
&gt;&gt;&gt; t3.writeToFile(<span class="py_string">"t3.tab"</span>, sep=<span class="py_string">"\t"</span>)
&gt;&gt;&gt; reader = SeparatorFormatParser(with_header=<span class="py_keyword">True</span>,converter=converter,
...      sep=<span class="py_string">"\t"</span>)
&gt;&gt;&gt; t3a = LoadTable(filename=<span class="py_string">"t3.tab"</span>, reader=reader, title=<span class="py_string">"new title"</span>,
...       space=2)
&gt;&gt;&gt; <span class="py_keyword">print</span> t3a
new title
======================================================
edge.name  edge.parent  length       x       y       z
------------------------------------------------------
    Human       edge.0  4.0000  1.0000  3.0000  6.0000
HowlerMon       edge.0  4.0000  1.0000  3.0000  6.0000
    Mouse       edge.1  4.0000  1.0000  3.0000  6.0000
NineBande         root  4.0000  1.0000  3.0000  6.0000
 DogFaced         root  4.0000  1.0000  3.0000  6.0000
   edge.0       edge.1  4.0000  1.0000  3.0000  6.0000
   edge.1         root  4.0000  1.0000  3.0000  6.0000
------------------------------------------------------</pre><p>We also test the reader function for a 't' delimited format with missing data at the end.</p>
<pre class="code">&gt;&gt;&gt; data = [<span class="py_string">'ab\tcd\t'</span>, <span class="py_string">'ab\tcd\tef'</span>]
&gt;&gt;&gt; tab_reader = SeparatorFormatParser(sep=<span class="py_string">'\t'</span>)
&gt;&gt;&gt; <span class="py_keyword">for</span> line <span class="py_keyword">in</span> tab_reader(data):
...     <span class="py_keyword">assert</span> len(line) == 3, line</pre><p>We can likewise specify a writer, using a custom field formatter and provide this to the <tt class="docutils literal"><span class="pre">Table</span></tt> directly for writing. We first illustrate how the writer works to generate output. We then use it to escape some text fields in quotes. In order to read that back in, we define a custom reader that strips these quotes off.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.format.table <span class="py_keyword">import</span> FormatFields, SeparatorFormatWriter
&gt;&gt;&gt; formatter = FormatFields([(0,<span class="py_string">'"%s"'</span>), (1,<span class="py_string">'"%s"'</span>)])
&gt;&gt;&gt; writer = SeparatorFormatWriter(formatter=formatter, sep=<span class="py_string">" | "</span>)
&gt;&gt;&gt; <span class="py_keyword">for</span> formatted <span class="py_keyword">in</span> writer(comma_sep, has_header=<span class="py_keyword">True</span>):
...      <span class="py_keyword">print</span> formatted
edge.name | edge.parent | length | x | y | z
<span class="py_string">"Human"</span> | <span class="py_string">"edge.0"</span> | 4.0 | 1.0 | 3.0 | 6.0
<span class="py_string">"HowlerMon"</span> | <span class="py_string">"edge.0"</span> | 4.0 | 1.0 | 3.0 | 6.0
<span class="py_string">"Mouse"</span> | <span class="py_string">"edge.1"</span> | 4.0 | 1.0 | 3.0 | 6.0
<span class="py_string">"NineBande"</span> | <span class="py_string">"root"</span> | 4.0 | 1.0 | 3.0 | 6.0
<span class="py_string">"DogFaced"</span> | <span class="py_string">"root"</span> | 4.0 | 1.0 | 3.0 | 6.0
<span class="py_string">"edge.0"</span> | <span class="py_string">"edge.1"</span> | 4.0 | 1.0 | 3.0 | 6.0
<span class="py_string">"edge.1"</span> | <span class="py_string">"root"</span> | 4.0 | 1.0 | 3.0 | 6.0
&gt;&gt;&gt; t3.writeToFile(filename=<span class="py_string">"t3.tab"</span>, writer=writer)
&gt;&gt;&gt; strip = <span class="py_keyword">lambda</span> x: x.replace(<span class="py_string">'"'</span>, <span class="py_string">''</span>)
&gt;&gt;&gt; converter = ConvertFields([(0,strip), (1, strip)])
&gt;&gt;&gt; reader = SeparatorFormatParser(with_header=<span class="py_keyword">True</span>, converter=converter,
...       sep=<span class="py_string">"|"</span>, strip_wspace=<span class="py_keyword">True</span>)
&gt;&gt;&gt; t3a = LoadTable(filename=<span class="py_string">"t3.tab"</span>, reader=reader, title=<span class="py_string">"new title"</span>,
...       space=2)
&gt;&gt;&gt; <span class="py_keyword">print</span> t3a
new title
=============================================
edge.name  edge.parent  length    x    y    z
---------------------------------------------
    Human       edge.0     4.0  1.0  3.0  6.0
HowlerMon       edge.0     4.0  1.0  3.0  6.0
    Mouse       edge.1     4.0  1.0  3.0  6.0
NineBande         root     4.0  1.0  3.0  6.0
 DogFaced         root     4.0  1.0  3.0  6.0
   edge.0       edge.1     4.0  1.0  3.0  6.0
   edge.1         root     4.0  1.0  3.0  6.0
---------------------------------------------</pre><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">There are performance issues for large files. Pickling has proven very slow for saving very large files and introduces significant file size bloat. A simple delimited format is much more efficient both storage wise and, if you use a custom reader, to generate and read. A custom reader was approximately 6 fold faster than the standard delimited file reader.</td>
</tr>
</tbody>
</table>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id25" id="table-slicing-and-iteration" name="table-slicing-and-iteration">Table slicing and iteration</a></h3>
<p>The Table class is capable of slicing by row, range of rows, column or range of columns headings or used to identify a single cell. Slicing using the method <tt class="docutils literal"><span class="pre">getColumns</span></tt> can also be used to reorder columns. In the case of columns, either the string headings or their position integers can be used. For rows, if <tt class="docutils literal"><span class="pre">row_ids</span></tt> was specified as <tt class="docutils literal"><span class="pre">True</span></tt> the 0'th cell in each row can also be used.</p>
<pre class="code">&gt;&gt;&gt; t4 = Table([<span class="py_string">'edge.name'</span>, <span class="py_string">'edge.parent'</span>, <span class="py_string">'length'</span>, <span class="py_string">'x'</span>, <span class="py_string">'y'</span>, <span class="py_string">'z'</span>], d2D,
... row_order = row_order, row_ids = <span class="py_keyword">True</span>, title = <span class="py_string">'My Title'</span>)</pre><p>We subset <tt class="docutils literal"><span class="pre">t4</span></tt> by column and reorder them.</p>
<pre class="code">&gt;&gt;&gt; new = t4.getColumns([<span class="py_string">'z'</span>, <span class="py_string">'y'</span>])
&gt;&gt;&gt; <span class="py_keyword">print</span> new
My Title
=============================
edge.name         z         y
-----------------------------
    Human    6.0000    3.0000
HowlerMon    6.0000    3.0000
    Mouse    6.0000    3.0000
NineBande    6.0000    3.0000
 DogFaced    6.0000    3.0000
   edge.0    6.0000    3.0000
   edge.1    6.0000    3.0000
-----------------------------</pre><p>We use the column position indexes to do get the same table.</p>
<pre class="code">&gt;&gt;&gt; new = t4.getColumns([5, 4])
&gt;&gt;&gt; <span class="py_keyword">print</span> new
My Title
=============================
edge.name         z         y
-----------------------------
    Human    6.0000    3.0000
HowlerMon    6.0000    3.0000
    Mouse    6.0000    3.0000
NineBande    6.0000    3.0000
 DogFaced    6.0000    3.0000
   edge.0    6.0000    3.0000
   edge.1    6.0000    3.0000
-----------------------------</pre><p>We can also using more general slicing, by both rows and columns. The following returns all rows from 4 on, and columns up to (but excluding) 'y':</p>
<pre class="code">&gt;&gt;&gt; k = t4[4:, :<span class="py_string">'y'</span>]
&gt;&gt;&gt; <span class="py_keyword">print</span> k
My Title
============================================
edge.name    edge.parent    length         x
--------------------------------------------
 DogFaced           root    4.0000    1.0000
   edge.0         edge.1    4.0000    1.0000
   edge.1           root    4.0000    1.0000
--------------------------------------------</pre><p>We can explicitly reference individual cells, in this case using both row and column keys.</p>
<pre class="code">&gt;&gt;&gt; val = t4[<span class="py_string">'HowlerMon'</span>, <span class="py_string">'y'</span>]
&gt;&gt;&gt; <span class="py_keyword">print</span> val
3.0</pre><p>We slice a single row,</p>
<pre class="code">&gt;&gt;&gt; new = t4[3]
&gt;&gt;&gt; <span class="py_keyword">print</span> new
My Title
================================================================
edge.name    edge.parent    length         x         y         z
----------------------------------------------------------------
NineBande           root    4.0000    1.0000    3.0000    6.0000
----------------------------------------------------------------</pre><p>and range of rows.</p>
<pre class="code">&gt;&gt;&gt; new = t4[3:6]
&gt;&gt;&gt; <span class="py_keyword">print</span> new
My Title
================================================================
edge.name    edge.parent    length         x         y         z
----------------------------------------------------------------
NineBande           root    4.0000    1.0000    3.0000    6.0000
 DogFaced           root    4.0000    1.0000    3.0000    6.0000
   edge.0         edge.1    4.0000    1.0000    3.0000    6.0000
----------------------------------------------------------------</pre><p>You can get disjoint rows.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> t4.getDisjointRows([<span class="py_string">'Human'</span>, <span class="py_string">'Mouse'</span>, <span class="py_string">'DogFaced'</span>])
My Title
================================================================
edge.name    edge.parent    length         x         y         z
----------------------------------------------------------------
    Human         edge.0    4.0000    1.0000    3.0000    6.0000
    Mouse         edge.1    4.0000    1.0000    3.0000    6.0000
 DogFaced           root    4.0000    1.0000    3.0000    6.0000
----------------------------------------------------------------</pre><p>You can iterate over the table one row at a time and slice the rows. We illustrate this slicing a single column,</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">for</span> row <span class="py_keyword">in</span> t:
...     <span class="py_keyword">print</span> row[<span class="py_string">'Journal'</span>]
INT J PARASITOL
J MED ENTOMOL
Med Vet Entomol
INSECT MOL BIOL
J AM MOSQUITO CONTR
MOL PHYLOGENET EVOL
HEREDITY
AM J TROP MED HYG
MIL MED
MED J AUSTRALIA</pre><p>and for multiple columns.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">for</span> row <span class="py_keyword">in</span> t:
...     <span class="py_keyword">print</span> row[<span class="py_string">'Journal'</span>], row[<span class="py_string">'Impact'</span>]
INT J PARASITOL 2.9
J MED ENTOMOL 1.4
Med Vet Entomol 1.0
INSECT MOL BIOL 2.85
J AM MOSQUITO CONTR 0.811
MOL PHYLOGENET EVOL 2.8
HEREDITY 1.99
AM J TROP MED HYG 2.105
MIL MED 0.605
MED J AUSTRALIA 1.736</pre><p>The numerical slice equivalent to the first case above would be <tt class="docutils literal"><span class="pre">row[0]</span></tt>, to the second case either <tt class="docutils literal"><span class="pre">row[:]</span></tt>, <tt class="docutils literal"><span class="pre">row[:2]</span></tt>.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id26" id="filtering-tables-selecting-subsets-of-rows" name="filtering-tables-selecting-subsets-of-rows">Filtering tables - selecting subsets of rows</a></h3>
<p>We want to be able to slice a table, based on some condition(s), to produce a new subset table. For instance, we construct a table with type and probability values.</p>
<pre class="code">&gt;&gt;&gt; header = [<span class="py_string">'Gene'</span>, <span class="py_string">'type'</span>, <span class="py_string">'LR'</span>, <span class="py_string">'df'</span>, <span class="py_string">'Prob'</span>]
&gt;&gt;&gt; rows = ((<span class="py_string">'NP_003077_hs_mm_rn_dna'</span>, <span class="py_string">'Con'</span>, 2.5386013224378985, 1, 0.11109315773082831),
... (<span class="py_string">'NP_004893_hs_mm_rn_dna'</span>, <span class="py_string">'Con'</span>, 0.12135142635634111, 1, 0.72757335582240734),
... (<span class="py_string">'NP_005079_hs_mm_rn_dna'</span>, <span class="py_string">'Con'</span>, 0.95165949788861326, 1, 0.32929724584698283),
... (<span class="py_string">'NP_005500_hs_mm_rn_dna'</span>, <span class="py_string">'Con'</span>, 0.73827030202664901, 1, 0.39021552602340093),
... (<span class="py_string">'NP_055852_hs_mm_rn_dna'</span>, <span class="py_string">'Con'</span>, 1.0933217708952725e-07, 1, 0.99973617615127786),
... (<span class="py_string">'NP_057012_hs_mm_rn_dna'</span>, <span class="py_string">'Unco'</span>, 34.308128716646024, 1, 4.7041285669893972e-09),
... (<span class="py_string">'NP_061130_hs_mm_rn_dna'</span>, <span class="py_string">'Unco'</span>, 3.7985547146436147, 1, 0.051296842773762508),
... (<span class="py_string">'NP_065168_hs_mm_rn_dna'</span>, <span class="py_string">'Con'</span>, 89.976605494927753, 1, 2.4099285463629382e-21),
... (<span class="py_string">'NP_065396_hs_mm_rn_dna'</span>, <span class="py_string">'Unco'</span>, 11.891188830577448, 1, 0.0005640011189894644),
... (<span class="py_string">'NP_109590_hs_mm_rn_dna'</span>, <span class="py_string">'Con'</span>, 0.21207818314360338, 1, 0.64514339888725714),
... (<span class="py_string">'NP_116116_hs_mm_rn_dna'</span>, <span class="py_string">'Unco'</span>, 9.747428216541266, 1, 0.0017957376763436551))
&gt;&gt;&gt; t5 = Table(header, rows)
&gt;&gt;&gt; <span class="py_keyword">print</span> t5
=========================================================
                  Gene    type         LR    df      Prob
---------------------------------------------------------
NP_003077_hs_mm_rn_dna     Con     2.5386     1    0.1111
NP_004893_hs_mm_rn_dna     Con     0.1214     1    0.7276
NP_005079_hs_mm_rn_dna     Con     0.9517     1    0.3293
NP_005500_hs_mm_rn_dna     Con     0.7383     1    0.3902
NP_055852_hs_mm_rn_dna     Con     0.0000     1    0.9997
NP_057012_hs_mm_rn_dna    Unco    34.3081     1    0.0000
NP_061130_hs_mm_rn_dna    Unco     3.7986     1    0.0513
NP_065168_hs_mm_rn_dna     Con    89.9766     1    0.0000
NP_065396_hs_mm_rn_dna    Unco    11.8912     1    0.0006
NP_109590_hs_mm_rn_dna     Con     0.2121     1    0.6451
NP_116116_hs_mm_rn_dna    Unco     9.7474     1    0.0018
---------------------------------------------------------</pre><p>We then seek to obtain only those rows that contain probabilities &lt; 0.05. We use valid python code within a string. <strong>Note:</strong> Make sure your column headings could be valid python variable names or the string based approach will fail (you could use an external function instead, see below).</p>
<pre class="code">&gt;&gt;&gt; sub_table1 = t5.filtered(callback = <span class="py_string">"Prob &lt; 0.05"</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> sub_table1
=========================================================
                  Gene    type         LR    df      Prob
---------------------------------------------------------
NP_057012_hs_mm_rn_dna    Unco    34.3081     1    0.0000
NP_065168_hs_mm_rn_dna     Con    89.9766     1    0.0000
NP_065396_hs_mm_rn_dna    Unco    11.8912     1    0.0006
NP_116116_hs_mm_rn_dna    Unco     9.7474     1    0.0018
---------------------------------------------------------</pre><p>Using the above table we test the function to extract the raw data for a single column,</p>
<pre class="code">&gt;&gt;&gt; raw = sub_table1.getRawData(<span class="py_string">'LR'</span>)
&gt;&gt;&gt; raw
[34.308128716646024, 89.976605494927753, 11.891188830577448, 9.747428216541266]</pre><p>and from multiple columns.</p>
<pre class="code">&gt;&gt;&gt; raw = sub_table1.getRawData(columns = [<span class="py_string">'LR'</span>, <span class="py_string">'df'</span>, <span class="py_string">'Prob'</span>])
&gt;&gt;&gt; raw
[[34.308128716646024, 1, 4.7041285669893972e-09], [89.976605494927753, 1, 2.4099285463629382e-21], [11.891188830577448, 1, 0.0005640011189894644], [9.747428216541266, 1, 0.0017957376763436551]]</pre><p>We can also do filtering using an external function, in this case we use a <tt class="docutils literal"><span class="pre">lambda</span></tt> to obtain only those rows of type 'Unco' that contain probabilities &lt; 0.05, modifying our callback function.</p>
<pre class="code">&gt;&gt;&gt; func = <span class="py_keyword">lambda</span> (ty, pr): ty == <span class="py_string">'Unco'</span> <span class="py_keyword">and</span> pr &lt; 0.05
&gt;&gt;&gt; sub_table2 = t5.filtered(columns = (<span class="py_string">'type'</span>, <span class="py_string">'Prob'</span>), callback = func)
&gt;&gt;&gt; <span class="py_keyword">print</span> sub_table2
=========================================================
                  Gene    type         LR    df      Prob
---------------------------------------------------------
NP_057012_hs_mm_rn_dna    Unco    34.3081     1    0.0000
NP_065396_hs_mm_rn_dna    Unco    11.8912     1    0.0006
NP_116116_hs_mm_rn_dna    Unco     9.7474     1    0.0018
---------------------------------------------------------</pre><p>This can also be done using the string approach.</p>
<pre class="code">&gt;&gt;&gt; sub_table2 = t5.filtered(callback = <span class="py_string">"type == 'Unco' and Prob &lt; 0.05"</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> sub_table2
=========================================================
                  Gene    type         LR    df      Prob
---------------------------------------------------------
NP_057012_hs_mm_rn_dna    Unco    34.3081     1    0.0000
NP_065396_hs_mm_rn_dna    Unco    11.8912     1    0.0006
NP_116116_hs_mm_rn_dna    Unco     9.7474     1    0.0018
---------------------------------------------------------</pre></div>
<div class="section">
<h3><a class="toc-backref" href="#id27" id="appending-tables" name="appending-tables">Appending tables</a></h3>
<p>Tables may also be appended to each other, to make larger tables. We'll construct two simple tables to illustrate this.</p>
<pre class="code">&gt;&gt;&gt; geneA = Table([<span class="py_string">'edge.name'</span>, <span class="py_string">'edge.parent'</span>, <span class="py_string">'z'</span>], [[<span class="py_string">'Human'</span>,<span class="py_string">'root'</span>,
... 6.0],[<span class="py_string">'Mouse'</span>,<span class="py_string">'root'</span>, 6.0], [<span class="py_string">'Rat'</span>,<span class="py_string">'root'</span>, 6.0]],
... title=<span class="py_string">'Gene A'</span>)
&gt;&gt;&gt; geneB = Table([<span class="py_string">'edge.name'</span>, <span class="py_string">'edge.parent'</span>, <span class="py_string">'z'</span>], [[<span class="py_string">'Human'</span>,<span class="py_string">'root'</span>,
... 7.0],[<span class="py_string">'Mouse'</span>,<span class="py_string">'root'</span>, 7.0], [<span class="py_string">'Rat'</span>,<span class="py_string">'root'</span>, 7.0]],
... title=<span class="py_string">'Gene B'</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> geneB
Gene B
==================================
edge.name    edge.parent         z
----------------------------------
    Human           root    7.0000
    Mouse           root    7.0000
      Rat           root    7.0000
----------------------------------</pre><p>we now use the <tt class="docutils literal"><span class="pre">appended</span></tt> Table method to create a new table, specifying that we want a new column created (by passing the <tt class="docutils literal"><span class="pre">new_column</span></tt> argument a heading) in which the table titles will be placed.</p>
<pre class="code">&gt;&gt;&gt; new = geneA.appended(<span class="py_string">'Gene'</span>, geneB, title=<span class="py_string">'Appended tables'</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> new
Appended tables
============================================
  Gene    edge.name    edge.parent         z
--------------------------------------------
Gene A        Human           root    6.0000
Gene A        Mouse           root    6.0000
Gene A          Rat           root    6.0000
Gene B        Human           root    7.0000
Gene B        Mouse           root    7.0000
Gene B          Rat           root    7.0000
--------------------------------------------</pre><p>We repeat this without adding a new column.</p>
<pre class="code">&gt;&gt;&gt; new = geneA.appended(<span class="py_keyword">None</span>, geneB, title=<span class="py_string">"Appended, no new column"</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> new
Appended, no new column
==================================
edge.name    edge.parent         z
----------------------------------
    Human           root    6.0000
    Mouse           root    6.0000
      Rat           root    6.0000
    Human           root    7.0000
    Mouse           root    7.0000
      Rat           root    7.0000
----------------------------------</pre></div>
<div class="section">
<h3><a class="toc-backref" href="#id28" id="miscellaneous" name="miscellaneous">Miscellaneous</a></h3>
<p>Tables have a <tt class="docutils literal"><span class="pre">Shape</span></tt> attribute, which specifies <em>x</em> (number of columns) and <em>y</em> (number of rows). The attribute is a tuple and we illustrate it for the above <tt class="docutils literal"><span class="pre">sub_table</span></tt> tables. Combined with the <tt class="docutils literal"><span class="pre">filtered</span></tt> method, this attribute can tell you how many rows satisfy a specific condition.</p>
<pre class="code">&gt;&gt;&gt; t5.Shape
(11, 5)
&gt;&gt;&gt; sub_table1.Shape
(4, 5)
&gt;&gt;&gt; sub_table2.Shape
(3, 5)</pre><p>For instance, 3 of the 11 rows in <tt class="docutils literal"><span class="pre">t</span></tt> were significant and belonged to the <tt class="docutils literal"><span class="pre">Unco</span></tt> type.</p>
<p>For completeness, we generate a table with no rows and assess its shape.</p>
<pre class="code">&gt;&gt;&gt; func = <span class="py_keyword">lambda</span> (ty, pr): ty == <span class="py_string">'Unco'</span> <span class="py_keyword">and</span> pr &gt; 0.1
&gt;&gt;&gt; sub_table3 = t5.filtered(columns = (<span class="py_string">'type'</span>, <span class="py_string">'Prob'</span>), callback = func)
&gt;&gt;&gt; sub_table3.Shape
(0, 5)</pre><p>The distinct values can be obtained for a single column,</p>
<pre class="code">&gt;&gt;&gt; distinct = new.getDistinctValues(<span class="py_string">"edge.name"</span>)
&gt;&gt;&gt; <span class="py_keyword">assert</span> distinct == set([<span class="py_string">'Rat'</span>, <span class="py_string">'Mouse'</span>, <span class="py_string">'Human'</span>])</pre><p>or multiple columns</p>
<pre class="code">&gt;&gt;&gt; distinct = new.getDistinctValues([<span class="py_string">"edge.parent"</span>, <span class="py_string">"z"</span>])
&gt;&gt;&gt; <span class="py_keyword">assert</span> distinct == set([(<span class="py_string">'root'</span>, 6.0), (<span class="py_string">'root'</span>, 7.0)]), distinct</pre><p>We can compute column sums. This will fail if there are non-numerical values in a column.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">assert</span> new.summed(<span class="py_string">'z'</span>) == 39., new.summed(<span class="py_string">'z'</span>)</pre></div>
<div class="section">
<h3><a class="toc-backref" href="#id29" id="extending-tables" name="extending-tables">Extending tables</a></h3>
<p>In some cases it is desirable to compute an additional column from existing column values. This is done using the <tt class="docutils literal"><span class="pre">withNewColumn</span></tt> method. We'll use t4 from above, adding two of the columns to create an additional column.</p>
<pre class="code">&gt;&gt;&gt; t7 = t4.withNewColumn(<span class="py_string">'Sum'</span>, callback=<span class="py_string">"z+x"</span>, digits=2)
&gt;&gt;&gt; <span class="py_keyword">print</span> t7
My Title
==================================================================
edge.name    edge.parent    length       x       y       z     Sum
------------------------------------------------------------------
    Human         edge.0      4.00    1.00    3.00    6.00    7.00
HowlerMon         edge.0      4.00    1.00    3.00    6.00    7.00
    Mouse         edge.1      4.00    1.00    3.00    6.00    7.00
NineBande           root      4.00    1.00    3.00    6.00    7.00
 DogFaced           root      4.00    1.00    3.00    6.00    7.00
   edge.0         edge.1      4.00    1.00    3.00    6.00    7.00
   edge.1           root      4.00    1.00    3.00    6.00    7.00
------------------------------------------------------------------</pre><p>We test this with an externally defined function.</p>
<pre class="code">&gt;&gt;&gt; func = <span class="py_keyword">lambda</span> (x, y): x * y
&gt;&gt;&gt; t7 = t4.withNewColumn(<span class="py_string">'Sum'</span>, callback=func, columns=(<span class="py_string">"y"</span>,<span class="py_string">"z"</span>),
... digits=2)
&gt;&gt;&gt; <span class="py_keyword">print</span> t7
My Title
===================================================================
edge.name    edge.parent    length       x       y       z      Sum
-------------------------------------------------------------------
    Human         edge.0      4.00    1.00    3.00    6.00    18.00
HowlerMon         edge.0      4.00    1.00    3.00    6.00    18.00
    Mouse         edge.1      4.00    1.00    3.00    6.00    18.00
NineBande           root      4.00    1.00    3.00    6.00    18.00
 DogFaced           root      4.00    1.00    3.00    6.00    18.00
   edge.0         edge.1      4.00    1.00    3.00    6.00    18.00
   edge.1           root      4.00    1.00    3.00    6.00    18.00
-------------------------------------------------------------------
&gt;&gt;&gt; func = <span class="py_keyword">lambda</span> x: x**3
&gt;&gt;&gt; t7 = t4.withNewColumn(<span class="py_string">'Sum'</span>, callback=func, columns=<span class="py_string">"y"</span>, digits=2)
&gt;&gt;&gt; <span class="py_keyword">print</span> t7
My Title
===================================================================
edge.name    edge.parent    length       x       y       z      Sum
-------------------------------------------------------------------
    Human         edge.0      4.00    1.00    3.00    6.00    27.00
HowlerMon         edge.0      4.00    1.00    3.00    6.00    27.00
    Mouse         edge.1      4.00    1.00    3.00    6.00    27.00
NineBande           root      4.00    1.00    3.00    6.00    27.00
 DogFaced           root      4.00    1.00    3.00    6.00    27.00
   edge.0         edge.1      4.00    1.00    3.00    6.00    27.00
   edge.1           root      4.00    1.00    3.00    6.00    27.00
-------------------------------------------------------------------</pre></div>
<div class="section">
<h3><a class="toc-backref" href="#id30" id="sorting-tables" name="sorting-tables">Sorting tables</a></h3>
<p>We want a table sorted according to values in a column.</p>
<pre class="code">&gt;&gt;&gt; sorted = t5.sorted(columns = <span class="py_string">'LR'</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> sorted
=========================================================
                  Gene    type         LR    df      Prob
---------------------------------------------------------
NP_055852_hs_mm_rn_dna     Con     0.0000     1    0.9997
NP_004893_hs_mm_rn_dna     Con     0.1214     1    0.7276
NP_109590_hs_mm_rn_dna     Con     0.2121     1    0.6451
NP_005500_hs_mm_rn_dna     Con     0.7383     1    0.3902
NP_005079_hs_mm_rn_dna     Con     0.9517     1    0.3293
NP_003077_hs_mm_rn_dna     Con     2.5386     1    0.1111
NP_061130_hs_mm_rn_dna    Unco     3.7986     1    0.0513
NP_116116_hs_mm_rn_dna    Unco     9.7474     1    0.0018
NP_065396_hs_mm_rn_dna    Unco    11.8912     1    0.0006
NP_057012_hs_mm_rn_dna    Unco    34.3081     1    0.0000
NP_065168_hs_mm_rn_dna     Con    89.9766     1    0.0000
---------------------------------------------------------</pre><p>We want a table sorted according to values in a subset of columns, note the order of columns determines the sort order.</p>
<pre class="code">&gt;&gt;&gt; sorted = t5.sorted(columns=(<span class="py_string">'LR'</span>, <span class="py_string">'type'</span>))
&gt;&gt;&gt; <span class="py_keyword">print</span> sorted
=========================================================
                  Gene    type         LR    df      Prob
---------------------------------------------------------
NP_055852_hs_mm_rn_dna     Con     0.0000     1    0.9997
NP_004893_hs_mm_rn_dna     Con     0.1214     1    0.7276
NP_109590_hs_mm_rn_dna     Con     0.2121     1    0.6451
NP_005500_hs_mm_rn_dna     Con     0.7383     1    0.3902
NP_005079_hs_mm_rn_dna     Con     0.9517     1    0.3293
NP_003077_hs_mm_rn_dna     Con     2.5386     1    0.1111
NP_061130_hs_mm_rn_dna    Unco     3.7986     1    0.0513
NP_116116_hs_mm_rn_dna    Unco     9.7474     1    0.0018
NP_065396_hs_mm_rn_dna    Unco    11.8912     1    0.0006
NP_057012_hs_mm_rn_dna    Unco    34.3081     1    0.0000
NP_065168_hs_mm_rn_dna     Con    89.9766     1    0.0000
---------------------------------------------------------</pre><p>We now do a sort based on 2 columns.</p>
<pre class="code">&gt;&gt;&gt; sorted = t5.sorted(columns=(<span class="py_string">'type'</span>, <span class="py_string">'LR'</span>))
&gt;&gt;&gt; <span class="py_keyword">print</span> sorted
=========================================================
                  Gene    type         LR    df      Prob
---------------------------------------------------------
NP_055852_hs_mm_rn_dna     Con     0.0000     1    0.9997
NP_004893_hs_mm_rn_dna     Con     0.1214     1    0.7276
NP_109590_hs_mm_rn_dna     Con     0.2121     1    0.6451
NP_005500_hs_mm_rn_dna     Con     0.7383     1    0.3902
NP_005079_hs_mm_rn_dna     Con     0.9517     1    0.3293
NP_003077_hs_mm_rn_dna     Con     2.5386     1    0.1111
NP_065168_hs_mm_rn_dna     Con    89.9766     1    0.0000
NP_061130_hs_mm_rn_dna    Unco     3.7986     1    0.0513
NP_116116_hs_mm_rn_dna    Unco     9.7474     1    0.0018
NP_065396_hs_mm_rn_dna    Unco    11.8912     1    0.0006
NP_057012_hs_mm_rn_dna    Unco    34.3081     1    0.0000
---------------------------------------------------------</pre><p>Reverse sort a single column</p>
<pre class="code">&gt;&gt;&gt; sorted = t5.sorted(<span class="py_string">'LR'</span>, reverse = <span class="py_string">'LR'</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> sorted
=========================================================
                  Gene    type         LR    df      Prob
---------------------------------------------------------
NP_065168_hs_mm_rn_dna     Con    89.9766     1    0.0000
NP_057012_hs_mm_rn_dna    Unco    34.3081     1    0.0000
NP_065396_hs_mm_rn_dna    Unco    11.8912     1    0.0006
NP_116116_hs_mm_rn_dna    Unco     9.7474     1    0.0018
NP_061130_hs_mm_rn_dna    Unco     3.7986     1    0.0513
NP_003077_hs_mm_rn_dna     Con     2.5386     1    0.1111
NP_005079_hs_mm_rn_dna     Con     0.9517     1    0.3293
NP_005500_hs_mm_rn_dna     Con     0.7383     1    0.3902
NP_109590_hs_mm_rn_dna     Con     0.2121     1    0.6451
NP_004893_hs_mm_rn_dna     Con     0.1214     1    0.7276
NP_055852_hs_mm_rn_dna     Con     0.0000     1    0.9997
---------------------------------------------------------</pre><p>Reverse sort one column but not another</p>
<pre class="code">&gt;&gt;&gt; sorted = t5.sorted(columns=(<span class="py_string">'type'</span>, <span class="py_string">'LR'</span>), reverse = <span class="py_string">'LR'</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> sorted
=========================================================
                  Gene    type         LR    df      Prob
---------------------------------------------------------
NP_065168_hs_mm_rn_dna     Con    89.9766     1    0.0000
NP_003077_hs_mm_rn_dna     Con     2.5386     1    0.1111
NP_005079_hs_mm_rn_dna     Con     0.9517     1    0.3293
NP_005500_hs_mm_rn_dna     Con     0.7383     1    0.3902
NP_109590_hs_mm_rn_dna     Con     0.2121     1    0.6451
NP_004893_hs_mm_rn_dna     Con     0.1214     1    0.7276
NP_055852_hs_mm_rn_dna     Con     0.0000     1    0.9997
NP_057012_hs_mm_rn_dna    Unco    34.3081     1    0.0000
NP_065396_hs_mm_rn_dna    Unco    11.8912     1    0.0006
NP_116116_hs_mm_rn_dna    Unco     9.7474     1    0.0018
NP_061130_hs_mm_rn_dna    Unco     3.7986     1    0.0513
---------------------------------------------------------</pre><p>Reverse sort both columns.</p>
<pre class="code">&gt;&gt;&gt; sorted = t5.sorted(columns=(<span class="py_string">'type'</span>, <span class="py_string">'LR'</span>), reverse = (<span class="py_string">'type'</span>, <span class="py_string">'LR'</span>))
&gt;&gt;&gt; <span class="py_keyword">print</span> sorted
=========================================================
                  Gene    type         LR    df      Prob
---------------------------------------------------------
NP_057012_hs_mm_rn_dna    Unco    34.3081     1    0.0000
NP_065396_hs_mm_rn_dna    Unco    11.8912     1    0.0006
NP_116116_hs_mm_rn_dna    Unco     9.7474     1    0.0018
NP_061130_hs_mm_rn_dna    Unco     3.7986     1    0.0513
NP_065168_hs_mm_rn_dna     Con    89.9766     1    0.0000
NP_003077_hs_mm_rn_dna     Con     2.5386     1    0.1111
NP_005079_hs_mm_rn_dna     Con     0.9517     1    0.3293
NP_005500_hs_mm_rn_dna     Con     0.7383     1    0.3902
NP_109590_hs_mm_rn_dna     Con     0.2121     1    0.6451
NP_004893_hs_mm_rn_dna     Con     0.1214     1    0.7276
NP_055852_hs_mm_rn_dna     Con     0.0000     1    0.9997
---------------------------------------------------------</pre></div>
<div class="section">
<h3><a class="toc-backref" href="#id31" id="joining-tables" name="joining-tables">Joining Tables</a></h3>
<p>The Table object is capable of joins or merging of records in two tables. There are two fundamental types of joins -- inner and outer -- with there being different sub-types. We demonstrate these first constructing some simple tables.</p>
<pre class="code">&gt;&gt;&gt; a=Table(header=[<span class="py_string">"index"</span>, <span class="py_string">"col2"</span>,<span class="py_string">"col3"</span>],
...         rows=[[1,2,3],[2,3,1],[2,6,5]], title=<span class="py_string">"A"</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> a
A
=====================
index    col2    col3
---------------------
    1       2       3
    2       3       1
    2       6       5
---------------------
&gt;&gt;&gt; b=Table(header=[<span class="py_string">"index"</span>, <span class="py_string">"col2"</span>,<span class="py_string">"col3"</span>],
...         rows=[[1,2,3],[2,2,1],[3,6,3]], title=<span class="py_string">"B"</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> b
B
=====================
index    col2    col3
---------------------
    1       2       3
    2       2       1
    3       6       3
---------------------
&gt;&gt;&gt; c=Table(header=[<span class="py_string">"index"</span>,<span class="py_string">"col_c2"</span>],rows=[[1,2],[3,2],[3,5]],title=<span class="py_string">"C"</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> c
C
===============
index    col_c2
---------------
    1         2
    3         2
    3         5
---------------</pre><p>For a natural inner join, only 1 copy of columns with the same name are retained. So we expect the headings to be identical between the table <tt class="docutils literal"><span class="pre">a</span></tt>/<tt class="docutils literal"><span class="pre">b</span></tt> and the result of <tt class="docutils literal"><span class="pre">a.joined(b)</span></tt> or <tt class="docutils literal"><span class="pre">b.joined(a)</span></tt>.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">assert</span> a.joined(b).Header == b.Header
&gt;&gt;&gt; <span class="py_keyword">assert</span> b.joined(a).Header == a.Header</pre><p>For a standard inner join, the joined table should contain all columns from <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> excepting the index column(s). Simply providing a column name (or index) selects this behaviour. Note that in this case, column names from the second table are made unique by prefixing them with that tables title. If the provided tables do not have a title, a <tt class="docutils literal"><span class="pre">RuntimeError</span></tt> is raised.</p>
<pre class="code">&gt;&gt;&gt; b.Title = <span class="py_keyword">None</span>
&gt;&gt;&gt; <span class="py_keyword">try</span>:
...     a.joined(b)
... <span class="py_keyword">except</span> RuntimeError:
...     <span class="py_keyword">pass</span>
&gt;&gt;&gt; b.Title = <span class="py_string">'B'</span>
&gt;&gt;&gt; <span class="py_keyword">assert</span> a.joined(b, <span class="py_string">"index"</span>).Header == [<span class="py_string">"index"</span>, <span class="py_string">"col2"</span>, <span class="py_string">"col3"</span>,
...                                        <span class="py_string">"B_col2"</span>, <span class="py_string">"B_col3"</span>]</pre><p>Note that the table title's were used to prefix the column headings from the second table. We further test this using table <tt class="docutils literal"><span class="pre">c</span></tt> which has different dimensions.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">assert</span> a.joined(c,<span class="py_string">"index"</span>).Header == [<span class="py_string">"index"</span>,<span class="py_string">"col2"</span>,<span class="py_string">"col3"</span>,
...                                       <span class="py_string">"C_col_c2"</span>]</pre><p>It's also possible to specify index columns using numerical values, the results of which should be the same.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">assert</span> a.joined(b,[0, 2]).getRawData() ==\
...                          a.joined(b,[<span class="py_string">"index"</span>,<span class="py_string">"col3"</span>]).getRawData()</pre><p>Additionally, it's possible to provide two series of indices for the two tables. Here, they have identical values.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">assert</span> a.joined(b, [<span class="py_string">"index"</span>, <span class="py_string">"col3"</span>],[<span class="py_string">"index"</span>, <span class="py_string">"col3"</span>]).getRawData()\
...         == a.joined(b,[<span class="py_string">"index"</span>,<span class="py_string">"col3"</span>]).getRawData()</pre><p>The results of a standard join between tables <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> are</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> a.joined(b, [<span class="py_string">"index"</span>], title=<span class="py_string">'A&amp;B'</span>)
A&amp;B
=========================================
index    col2    col3    B_col2    B_col3
-----------------------------------------
    1       2       3         2         3
    2       3       1         2         1
    2       6       5         2         1
-----------------------------------------</pre><p>We demo the table specific indices.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> a.joined(c, [<span class="py_string">"col2"</span>], [<span class="py_string">"index"</span>], title=<span class="py_string">'A&amp;C by "col2/index"'</span>)
A&amp;C by <span class="py_string">"col2/index"</span>
=================================
index    col2    col3    C_col_c2
---------------------------------
    2       3       1           2
    2       3       1           5
---------------------------------</pre><p>Tables <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">c</span></tt> share a single row with the same value in the <tt class="docutils literal"><span class="pre">index</span></tt> column, hence a join by that index should return a table with just that row.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> a.joined(c, <span class="py_string">"index"</span>, title=<span class="py_string">'A&amp;C by "index"'</span>)
A&amp;C by <span class="py_string">"index"</span>
=================================
index    col2    col3    C_col_c2
---------------------------------
    1       2       3           2
---------------------------------</pre><p>A natural join of tables <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> results in a table with only rows that were identical between the two parents.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> a.joined(b, title=<span class="py_string">'A&amp;B Natural Join'</span>)
A&amp;B Natural Join
=====================
index    col2    col3
---------------------
    1       2       3
---------------------</pre><p>We test the outer join by defining an additional table with different dimensions, and conducting a join specifying <tt class="docutils literal"><span class="pre">inner_join=False</span></tt>.</p>
<pre class="code">&gt;&gt;&gt; d=Table(header=[<span class="py_string">"index"</span>, <span class="py_string">"col_c2"</span>], rows=[[5,42],[6,23]], title=<span class="py_string">"D"</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> d
D
===============
index    col_c2
---------------
    5        42
    6        23
---------------
&gt;&gt;&gt; <span class="py_keyword">print</span> c.joined(d,inner_join=<span class="py_keyword">False</span>, title=<span class="py_string">'C&amp;D Outer join'</span>)
C&amp;D Outer join
======================================
index    col_c2    D_index    D_col_c2
--------------------------------------
    1         2          5          42
    1         2          6          23
    3         2          5          42
    3         2          6          23
    3         5          5          42
    3         5          6          23
--------------------------------------</pre><p>We establish the <tt class="docutils literal"><span class="pre">joined</span></tt> method works for mixtures of character and numerical data, setting some indices and some cell values to be strings.</p>
<pre class="code">&gt;&gt;&gt; a=Table(header=[<span class="py_string">"index"</span>, <span class="py_string">"col2"</span>,<span class="py_string">"col3"</span>],
...         rows=[[1,2,<span class="py_string">"3"</span>],[<span class="py_string">"2"</span>,3,1],[2,6,5]], title=<span class="py_string">"A"</span>)
&gt;&gt;&gt; b=Table(header=[<span class="py_string">"index"</span>, <span class="py_string">"col2"</span>,<span class="py_string">"col3"</span>],
...         rows=[[1,2,<span class="py_string">"3"</span>],[<span class="py_string">"2"</span>,2,1],[3,6,3]], title=<span class="py_string">"B"</span>)
&gt;&gt;&gt; <span class="py_keyword">assert</span> a.joined(b, [<span class="py_string">"index"</span>, <span class="py_string">"col3"</span>],[<span class="py_string">"index"</span>, <span class="py_string">"col3"</span>]).getRawData()\
...         == a.joined(b,[<span class="py_string">"index"</span>,<span class="py_string">"col3"</span>]).getRawData()</pre><p>We test that the <tt class="docutils literal"><span class="pre">joined</span></tt> method works when the column index orders differ.</p>
<pre class="code">&gt;&gt;&gt; t1_header = [<span class="py_string">'a'</span>, <span class="py_string">'b'</span>]
&gt;&gt;&gt; t1_rows = [(1,2),(3,4)]
&gt;&gt;&gt; t2_header = [<span class="py_string">'b'</span>, <span class="py_string">'c'</span>]
&gt;&gt;&gt; t2_rows = [(3,6),(4,8)]
&gt;&gt;&gt; t1 = Table(header = t1_header, rows = t1_rows, title=<span class="py_string">'t1'</span>)
&gt;&gt;&gt; t2 = Table(header = t2_header, rows = t2_rows, title=<span class="py_string">'t2'</span>)
&gt;&gt;&gt; t3 = t1.joined(t2, columns_self = [<span class="py_string">"b"</span>], columns_other = [<span class="py_string">"b"</span>])
&gt;&gt;&gt; <span class="py_keyword">print</span> t3
==============
a    b    t2_c
--------------
3    4       8
--------------</pre><p>We then establish that a join with no values does not cause a failure, just returns an empty <tt class="docutils literal"><span class="pre">Table</span></tt>.</p>
<pre class="code">&gt;&gt;&gt; t4_header = [<span class="py_string">'b'</span>, <span class="py_string">'c'</span>]
&gt;&gt;&gt; t4_rows = [(5,6),(7,8)]
&gt;&gt;&gt; t4 = LoadTable(header = t4_header, rows = t4_rows)
&gt;&gt;&gt; t4.Title = <span class="py_string">'t4'</span>
&gt;&gt;&gt; t5 = t1.joined(t4, columns_self = [<span class="py_string">"b"</span>], columns_other = [<span class="py_string">"b"</span>])</pre></div>
<div class="section">
<h3><a class="toc-backref" href="#id32" id="counting-rows" name="counting-rows">Counting rows</a></h3>
<p>We can count the number of rows for which a condition holds. This method uses the same arguments as <tt class="docutils literal"><span class="pre">filtered</span></tt> but returns an integer result only.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> c.count(<span class="py_string">"col_c2 == 2"</span>)
2
&gt;&gt;&gt; <span class="py_keyword">print</span> c.joined(d,inner_join=<span class="py_keyword">False</span>).count(<span class="py_string">"index==3 and D_index==5"</span>)
2</pre></div>
<div class="section">
<h3><a class="toc-backref" href="#id33" id="cleanup" name="cleanup">Cleanup</a></h3>
<p>Import the <tt class="docutils literal"><span class="pre">os</span></tt> module so some file cleanup can be done at the end. To check the contents of those files, just delete the following prior to running the test. The try/except clause below is aimed at case where <tt class="docutils literal"><span class="pre">junk.pdf</span></tt> wasn't created due to <tt class="docutils literal"><span class="pre">reportlab</span></tt> not being present.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">import</span> os
&gt;&gt;&gt; to_delete = [<span class="py_string">'t3.pickle'</span>, <span class="py_string">'junk.pdf'</span>, <span class="py_string">'t2.csv'</span>, <span class="py_string">'t3.tab'</span>]
&gt;&gt;&gt; <span class="py_keyword">for</span> f <span class="py_keyword">in</span> to_delete:
...     <span class="py_keyword">try</span>:
...         os.remove(f)
...     <span class="py_keyword">except</span> OSError:
...         <span class="py_keyword">pass</span></pre></div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id34" id="data-visualisation" name="data-visualisation">Data Visualisation</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id35" id="drawing-dendrograms-and-saving-to-pdf" name="drawing-dendrograms-and-saving-to-pdf">Drawing dendrograms and saving to PDF</a></h2>
<p>From cogent import all the components we need.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs, LoadTree
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.evolve.models <span class="py_keyword">import</span> Y98
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.draw <span class="py_keyword">import</span> dendrogram</pre><p>Do a model, see the neutral test example for more details of this</p>
<pre class="code">&gt;&gt;&gt; al = LoadSeqs(<span class="py_string">"data/test.paml"</span>)
&gt;&gt;&gt; t = LoadTree(<span class="py_string">"data/test.tree"</span>)
&gt;&gt;&gt; sm = Y98()
&gt;&gt;&gt; nonneutral_lf = sm.makeLikelihoodFunction(t)
&gt;&gt;&gt; nonneutral_lf.setParamRule(<span class="py_string">"omega"</span>, is_independent = 1)
&gt;&gt;&gt; nonneutral_lf.setAlignment(al)
&gt;&gt;&gt; nonneutral_lf.optimise(tolerance = 1.0)
Outer loop = 0...
&gt;&gt;&gt; nonneutral_lf.optimise(local = <span class="py_keyword">True</span>)
    Number of function evaluations = 1; current F = 139...</pre><p>We will draw two different dendrograms -- one with branch lengths contemporaneous, the other where length is scaled NOTE: the argument names to dendrogram classes break from our convention of underscores_separating_argument_words. The convention used is that of ReportLab and these key-word arguments are passed directly to the underlying <tt class="docutils literal"><span class="pre">reportlab</span></tt> module.</p>
<p>Specify the dimensions of the canvas in pixels</p>
<pre class="code">&gt;&gt;&gt; height, width = 500, 700</pre><p>Dendrogram with branch lengths not proportional</p>
<pre class="code">&gt;&gt;&gt; np = dendrogram.ContemporaneousDendrogram(nonneutral_lf.tree)
&gt;&gt;&gt; np.drawToPDF(<span class="py_string">'tree-unscaled.pdf'</span> , width, height, stroke_width=2.0,
... show_params = [<span class="py_string">'r'</span>], label_template = <span class="py_string">"%(r).2g"</span>, shade_param = <span class="py_string">'r'</span>,
... max_value = 1.0, show_internal_labels=<span class="py_keyword">False</span>, font_size = 10,
... scale_bar = <span class="py_keyword">None</span>, use_lengths=<span class="py_keyword">False</span>)</pre><p>Dendrogram with branch lengths proportional</p>
<pre class="code">&gt;&gt;&gt; p = dendrogram.SquareDendrogram(nonneutral_lf.tree)
&gt;&gt;&gt; p.drawToPDF(<span class="py_string">'tree-scaled.pdf'</span>, width, height, stroke_width=2.0,
... shade_param = <span class="py_string">'r'</span>, max_value = 1.0, show_internal_labels=<span class="py_keyword">False</span>,
... font_size = 10)</pre><p>To save a tree for later reuse, either for analysis of drawing can be done using an annotated tree, which looks just like a tree, but has the maximum-likelihood parameter estimates attached to each tree edge. This tree can be saved in xml format, which preserve these parameter estimates. The annotated tree is obtained from the likelihood function with following command.</p>
<pre class="code">&gt;&gt;&gt; at = nonneutral_lf.getAnnotatedTree()</pre><p>Saving this to file is done using the normal <tt class="docutils literal"><span class="pre">writeToFile</span></tt> method, specifying a filename with the .xml suffix.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id36" id="drawing-a-dotplot" name="drawing-a-dotplot">Drawing a dotplot</a></h2>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.core <span class="py_keyword">import</span> annotation
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.draw <span class="py_keyword">import</span> dotplot</pre><p>Load the alignment for illustrative purposes, I'll make one sequence a different length than the other and introduce a custom sequence annotation for a miscellaneous feature. Normally, those annotations would be on the unaligned sequences.</p>
<pre class="code">&gt;&gt;&gt; aln = LoadSeqs(<span class="py_string">"data/test.paml"</span>)
&gt;&gt;&gt; feature = aln.addAnnotation(annotation.Feature, <span class="py_string">"misc_feature"</span>,
...                             <span class="py_string">"pprobs"</span>, [(38, 55)])
&gt;&gt;&gt; seq1 = aln.getSeq(<span class="py_string">'NineBande'</span>)[10:-3]
&gt;&gt;&gt; seq2 = aln.getSeq(<span class="py_string">'DogFaced'</span>)</pre><p>Write out the dotplot as a pdf file in the current directory note that seq1 will be the x-axis, and seq2 the y-axis.</p>
<pre class="code">&gt;&gt;&gt; dp = dotplot.Display2D(seq1,seq2)
&gt;&gt;&gt; filename = <span class="py_string">'dotplot_example.pdf'</span>
&gt;&gt;&gt; dp.drawToPDF(filename)</pre></div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id37" id="modelling-evolution" name="modelling-evolution">Modelling Evolution</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id38" id="the-simplest-script" name="the-simplest-script">The simplest script</a></h2>
<p>This is just about the simplest possible Cogent script. We use a canned nucleotide substitution model: the general time reversible model.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.evolve.models <span class="py_keyword">import</span> GTR
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs, LoadTree
&gt;&gt;&gt; model = GTR()
&gt;&gt;&gt; alignment = LoadSeqs(<span class="py_string">"data/test.paml"</span>)
&gt;&gt;&gt; tree = LoadTree(<span class="py_string">"data/test.tree"</span>)
&gt;&gt;&gt; likelihood_function = model.makeLikelihoodFunction(tree)
&gt;&gt;&gt; likelihood_function.setAlignment(alignment)
&gt;&gt;&gt; likelihood_function.optimise(show_progress = <span class="py_keyword">False</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> likelihood_function
Likelihood Function Table
==============================================
   A/C       A/G       A/T       C/G       C/T
----------------------------------------------
0.7120    2.1574    0.0000    0.4457    4.1764
----------------------------------------------
=============================
     edge    parent    length
-----------------------------
    Human    edge.0    0.0348
HowlerMon    edge.0    0.0168
   edge.0    edge.1    0.0222
    Mouse    edge.1    0.2047
   edge.1      root    0.0000
NineBande      root    0.0325
 DogFaced      root    0.0554
-----------------------------
===============
motif    mprobs
---------------
    T    0.1433
    C    0.1600
    A    0.3800
    G    0.3167
---------------</pre></div>
<div class="section">
<h2><a class="toc-backref" href="#id39" id="performing-a-relative-rate-test" name="performing-a-relative-rate-test">Performing a relative rate test</a></h2>
<p>From cogent import all the components we need</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs, LoadTree
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.evolve.models <span class="py_keyword">import</span> HKY85
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.maths <span class="py_keyword">import</span> stats</pre><p>Get your alignment and tree.</p>
<pre class="code">&gt;&gt;&gt; al = LoadSeqs(filename = <span class="py_string">"data/test.paml"</span>)
&gt;&gt;&gt; t = LoadTree(filename = <span class="py_string">"data/test.tree"</span>)</pre><p>Create a HKY85 model.</p>
<pre class="code">&gt;&gt;&gt; sm = HKY85()</pre><p>Make the controller object.</p>
<pre class="code">&gt;&gt;&gt; lf = sm.makeLikelihoodFunction(t)</pre><p>Set the local clock for humans &amp; Howler Monkey. This method is just a special interface to the more general setParamRules method.</p>
<pre class="code">&gt;&gt;&gt; lf.setLocalClock(<span class="py_string">"Human"</span>, <span class="py_string">"HowlerMon"</span>)</pre><p>Get the likelihood function object this object performs the actual likelihood calculation.</p>
<pre class="code">&gt;&gt;&gt; lf.setAlignment(al)</pre><p>Optimise the function capturing the return optimised lnL, and parameter value vector.</p>
<pre class="code">&gt;&gt;&gt; lf.optimise(show_progress = <span class="py_keyword">False</span>)</pre><p>View the resulting maximum-likelihood parameter values.</p>
<pre class="code">&gt;&gt;&gt; lf.setName(<span class="py_string">"clock"</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> lf
clock
======
 kappa
------
4.8020
------
=============================
     edge    parent    length
-----------------------------
    Human    edge.0    0.0257
HowlerMon    edge.0    0.0257
   edge.0    edge.1    0.0224
    Mouse    edge.1    0.2112
   edge.1      root    0.0000
NineBande      root    0.0327
 DogFaced      root    0.0545
-----------------------------
===============
motif    mprobs
---------------
    T    0.1433
    C    0.1600
    A    0.3800
    G    0.3167
---------------</pre><p>We extract the log-likelihood and number of free parameters for later use.</p>
<pre class="code">&gt;&gt;&gt; null_lnL = lf.getLogLikelihood()
&gt;&gt;&gt; null_nfp = lf.getNumFreeParams()</pre><p>Clear the local clock constraint, freeing up the branch lengths.</p>
<pre class="code">&gt;&gt;&gt; lf.setParamRule(<span class="py_string">'length'</span>, is_independent=<span class="py_keyword">True</span>)</pre><p>Run the optimiser capturing the return optimised lnL, and parameter value vector.</p>
<pre class="code">&gt;&gt;&gt; lf.optimise(show_progress=<span class="py_keyword">False</span>)</pre><p>View the resulting maximum-likelihood parameter values.</p>
<pre class="code">&gt;&gt;&gt; lf.setName(<span class="py_string">"non clock"</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> lf
non clock
======
 kappa
------
4.8027
------
=============================
     edge    parent    length
-----------------------------
    Human    edge.0    0.0347
HowlerMon    edge.0    0.0167
   edge.0    edge.1    0.0224
    Mouse    edge.1    0.2112
   edge.1      root    0.0000
NineBande      root    0.0327
 DogFaced      root    0.0545
-----------------------------
===============
motif    mprobs
---------------
    T    0.1433
    C    0.1600
    A    0.3800
    G    0.3167
---------------</pre><p>These two lnL's are now used to calculate the likelihood ratio statistic it's degrees-of-freedom and the probability of observing the LR.</p>
<pre class="code">&gt;&gt;&gt; LR = 2 * (lf.getLogLikelihood() - null_lnL)
&gt;&gt;&gt; df = lf.getNumFreeParams() - null_nfp
&gt;&gt;&gt; P = stats.chisqprob(LR, df)</pre><p>Print this and look up a chi-sq with number of edges - 1 degrees of freedom.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> <span class="py_string">"Likelihood ratio statistic = "</span>, LR
Likelihood ratio statistic =  0.34...
&gt;&gt;&gt; <span class="py_keyword">print</span> <span class="py_string">"degrees-of-freedom = "</span>, df
degrees-of-freedom =  1
&gt;&gt;&gt; <span class="py_keyword">print</span> <span class="py_string">"probability = "</span>, P
probability =  0.5...</pre></div>
<div class="section">
<h2><a class="toc-backref" href="#id40" id="a-test-of-the-neutral-theory" name="a-test-of-the-neutral-theory">A test of the neutral theory</a></h2>
<p>This file contains an example for performing a likelihood ratio test of neutrality. The test compares a model where the codon model parameter omega is constrained to be the same for all edges against one where each edge has its' own omega. From cogent import all the components we need.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs, LoadTree
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.evolve.models <span class="py_keyword">import</span> GY94
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.maths <span class="py_keyword">import</span> stats</pre><p>Get your alignment and tree.</p>
<pre class="code">&gt;&gt;&gt; al = LoadSeqs(<span class="py_string">"data/test.paml"</span>)
&gt;&gt;&gt; t = LoadTree(<span class="py_string">"data/test.tree"</span>)</pre><p>We use a Goldman Yang 1994 model.</p>
<pre class="code">&gt;&gt;&gt; sm = GY94()</pre><p>Make the controller object</p>
<pre class="code">&gt;&gt;&gt; lf = sm.makeLikelihoodFunction(t)</pre><p>Get the likelihood function object this object performs the actual likelihood calculation.</p>
<pre class="code">&gt;&gt;&gt; lf.setAlignment(al)</pre><p>By default, parameters other than branch lengths are treated as global in scope, so we don't need to do anything special here. We can influence how rigorous the optimisation will be, and switch between the global and local optimisers provided in the toolkit using arguments to the optimise method. The <tt class="docutils literal"><span class="pre">global_tolerance=1.0</span></tt> argument specifies conditions for an early break from simulated annealing which will be automatically followed by the Powell local optimiser. :Note: the 'results' are of course nonsense.</p>
<pre class="code">&gt;&gt;&gt; lf.optimise(global_tolerance = 1.0, show_progress=<span class="py_keyword">False</span>)</pre><p>View the resulting maximum-likelihood parameter values</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> lf
Likelihood Function Table
================
 kappa     omega
----------------
9.2738    1.8707
----------------
=============================
     edge    parent    length
-----------------------------
    Human    edge.0    0.0968
HowlerMon    edge.0    0.0540
   edge.0    edge.1    0.0654
    Mouse    edge.1    0.9115
   edge.1      root    0.0000
NineBande      root    0.1073
 DogFaced      root    0.1801...</pre><p>We'll get the lnL and number of free parameters for later use.</p>
<pre class="code">&gt;&gt;&gt; null_lnL = lf.getLogLikelihood()
&gt;&gt;&gt; null_nfp = lf.getNumFreeParams()</pre><p>Specify each edge has it's own omega by just modifying the existing <tt class="docutils literal"><span class="pre">lf</span></tt>. This means the new function will start with the above values.</p>
<pre class="code">&gt;&gt;&gt; lf.setParamRule(<span class="py_string">"omega"</span>, is_independent = <span class="py_keyword">True</span>)</pre><p>Optimise the likelihood function, this time just using the local optimiser.</p>
<pre class="code">&gt;&gt;&gt; lf.optimise(local = <span class="py_keyword">True</span>, show_progress=<span class="py_keyword">False</span>)</pre><p>View the resulting maximum-likelihood parameter values.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> lf
Likelihood Function Table
======
 kappa
------
8.9536
------
============================================
     edge    parent    length          omega
--------------------------------------------
    Human    edge.0    0.0970    999999.9815
HowlerMon    edge.0    0.0569    999999.9370
   edge.0    edge.1    0.0700    999999.9867
    Mouse    edge.1    0.9602         0.6964
   edge.1      root    0.0000    196705.5616
NineBande      root    0.1114    999999.9940
 DogFaced      root    0.1809         1.0999...</pre><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">The parameter estimates for <tt class="docutils literal"><span class="pre">omega</span></tt> are highly implausible, reflecting (in this case) our small and uninformative data set.</td>
</tr>
</tbody>
</table>
<p>Get out an annotated tree, it looks just like a tree, but has the maximum-likelihood parameter estimates attached to each tree edge. This object can be used for plotting, or to provide starting estimates to a related model.</p>
<pre class="code">&gt;&gt;&gt; at = lf.getAnnotatedTree()</pre><p>Get a dictionary of the statistics that I could use for post-processing.</p>
<pre class="code">&gt;&gt;&gt; sd = lf.getStatisticsAsDict(with_edge_names=<span class="py_keyword">True</span>)</pre><p>The lnL's from the two models are now used to calculate the likelihood ratio statistic (<tt class="docutils literal"><span class="pre">LR</span></tt>) it's degrees-of-freedom (<tt class="docutils literal"><span class="pre">df</span></tt>) and the probability (<tt class="docutils literal"><span class="pre">P</span></tt>) of observing the LR.</p>
<pre class="code">&gt;&gt;&gt; LR = 2 * (lf.getLogLikelihood() - null_lnL)
&gt;&gt;&gt; df = lf.getNumFreeParams() - null_nfp
&gt;&gt;&gt; P = stats.chisqprob(LR, df)</pre><p>Print this and look up a chi-sq with number of edges - 1 degrees of freedom.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> <span class="py_string">"Likelihood ratio statistic = "</span>, LR
Likelihood ratio statistic =  4.4...
&gt;&gt;&gt; <span class="py_keyword">print</span> <span class="py_string">"degrees-of-freedom = "</span>, df
degrees-of-freedom =  6
&gt;&gt;&gt; <span class="py_keyword">print</span> <span class="py_string">"probability = "</span>, P
probability =  0.6...</pre></div>
<div class="section">
<h2><a class="toc-backref" href="#id41" id="use-an-empirical-protein-substitution-model" name="use-an-empirical-protein-substitution-model">Use an empirical protein substitution model</a></h2>
<p>This file contains an example of importing an empirically determined protein substitution matrix such as Dayhoff et al 1978 and using it to create a substitution model. The globin alignment is from the PAML distribution.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs, LoadTree, PROTEIN
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.evolve.substitution_model <span class="py_keyword">import</span> EmpiricalProteinMatrix
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.parse.paml_matrix <span class="py_keyword">import</span> PamlMatrixParser</pre><p>Make a tree object.  In this case from a string.</p>
<pre class="code">&gt;&gt;&gt; treestring=<span class="py_string">"(((rabbit,rat),human),goat-cow,marsupial);"</span>
&gt;&gt;&gt; t = LoadTree(treestring=treestring)</pre><p>Import the alignment, explicitly setting the <tt class="docutils literal"><span class="pre">moltype</span></tt> to be protein</p>
<pre class="code">&gt;&gt;&gt; al = LoadSeqs(<span class="py_string">'data/abglobin_aa.phylip'</span>,
...                interleaved=<span class="py_keyword">True</span>,
...                moltype=PROTEIN,
...                )</pre><p>Open the file that contains the empirical matrix and parse the matrix and frequencies.</p>
<pre class="code">&gt;&gt;&gt; matrix_file = open(<span class="py_string">'data/dayhoff.dat'</span>)</pre><p>The <tt class="docutils literal"><span class="pre">PamlMatrixParser</span></tt> will import the matrix and frequency from files designed for Yang's PAML package.  This format is the lower half of the matrix in three letter amino acid name order white space delineated followed by motif frequencies in the same order.</p>
<pre class="code">&gt;&gt;&gt; empirical_matrix, empirical_frequencies = PamlMatrixParser(matrix_file)</pre><p>Create an Empirical Protein Matrix Substitution model object.  This will take the unscaled empirical matrix and use it and the motif frequencies to create a scaled Q matrix.</p>
<pre class="code">&gt;&gt;&gt; sm = EmpiricalProteinMatrix(empirical_matrix, empirical_frequencies)</pre><p>Make a parameter controller, likelihood function object and optimise.</p>
<pre class="code">&gt;&gt;&gt; lf = sm.makeLikelihoodFunction(t)
&gt;&gt;&gt; lf.setAlignment(al)
&gt;&gt;&gt; lf.optimise(show_progress = <span class="py_keyword">False</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> lf.getLogLikelihood()
-1706...
&gt;&gt;&gt; <span class="py_keyword">print</span> lf
Likelihood Function Table
=============================
     edge    parent    length
-----------------------------
   rabbit    edge.0    0.0785
      rat    edge.0    0.1750
   edge.0    edge.1    0.0324
    human    edge.1    0.0545
   edge.1      root    0.0269
 goat-cow      root    0.0972
marsupial      root    0.2424
-----------------------------
===============
motif    mprobs
---------------
    A    0.0871
    C    0.0335
    D    0.0469
    E    0.0495
    F    0.0398
    G    0.0886
    H    0.0336
    I    0.0369
    K    0.0805
    L    0.0854
    M    0.0148
    N    0.0404
    P    0.0507
    Q    0.0383
    R    0.0409
    S    0.0696
    T    0.0585
    V    0.0647
    W    0.0105
    Y    0.0299
---------------</pre></div>
<div class="section">
<h2><a class="toc-backref" href="#id42" id="analysis-of-rate-heterogeneity" name="analysis-of-rate-heterogeneity">Analysis of rate heterogeneity</a></h2>
<p>A simple example for analyses involving rate heterogeneity among sites. In this case we will simulate an alignment with two rate categories and then try to recover the rates from the alignment.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.evolve.substitution_model <span class="py_keyword">import</span> Nucleotide
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadTree</pre><p>Make an alignment with equal split between rates 0.6 and 0.2, and then concatenate them to create a new alignment.</p>
<pre class="code">&gt;&gt;&gt; model = Nucleotide(equal_motif_probs=<span class="py_keyword">True</span>)
&gt;&gt;&gt; tree = LoadTree(<span class="py_string">"data/test.tree"</span>)
&gt;&gt;&gt; lf = model.makeLikelihoodFunction(tree)
&gt;&gt;&gt; lf.setParamRule(<span class="py_string">'length'</span>, value=0.6, is_const=<span class="py_keyword">True</span>)
&gt;&gt;&gt; aln1 = lf.simulateAlignment(sequence_length=1000)
&gt;&gt;&gt; lf.setParamRule(<span class="py_string">'length'</span>, value=0.2, is_const=<span class="py_keyword">True</span>)
&gt;&gt;&gt; aln2 = lf.simulateAlignment(sequence_length=1000)
&gt;&gt;&gt; aln3 = aln1 + aln2</pre><p>Start from scratch, optimising only rates and the rate probability ratio.</p>
<pre class="code">&gt;&gt;&gt; model = Nucleotide(equal_motif_probs=<span class="py_keyword">True</span>, ordered_param=<span class="py_string">"rate"</span>,
...                    distribution=<span class="py_string">"free"</span>)
&gt;&gt;&gt; lf = model.makeLikelihoodFunction(tree, bins=2)
&gt;&gt;&gt; lf.setAlignment(aln3)
&gt;&gt;&gt; lf.optimise(local=<span class="py_keyword">True</span>, max_restarts=2, show_progress = <span class="py_keyword">False</span>)</pre><p>We want to know the bin probabilities and the posterior probabilities.</p>
<pre class="code">&gt;&gt;&gt; bprobs = lf.getParamValue(<span class="py_string">'bprobs'</span>)
&gt;&gt;&gt; pp = lf.getBinProbs()
&gt;&gt;&gt; <span class="py_keyword">for</span> bin <span class="py_keyword">in</span> [0,1]:
...     p = pp[bin]
...     rate = lf.getParamValue(<span class="py_string">'rate'</span>, bin=<span class="py_string">'bin%s'</span>%bin)
...     <span class="py_keyword">print</span> <span class="py_string">'%.2f of sites have rate %.2f'</span> % (bprobs[bin], rate)
...     <span class="py_keyword">print</span> <span class="py_string">'Avg probs over the fast (%.2f) and slow (%.2f) halves'</span> % \
...        (sum(p[:1000])/1000, sum(p[1000:])/1000)
0.12 of sites have rate 0.22
Avg probs over the fast (0.05) <span class="py_keyword">and</span> slow (0.18) halves
0.88 of sites have rate 1.10
Avg probs over the fast (0.95) <span class="py_keyword">and</span> slow (0.82) halves</pre><p>We'll now use a gamma distribution on the sample alignment, specifying the number of bins as 4. We specify that the bins have equal density using the <tt class="docutils literal"><span class="pre">lf.setParamRule('bprobs',</span> <span class="pre">is_const=True)</span></tt> command.</p>
<pre class="code">&gt;&gt;&gt; model = Nucleotide(equal_motif_probs=<span class="py_keyword">True</span>, ordered_param=<span class="py_string">"rate"</span>,
...                    distribution=<span class="py_string">"gamma"</span>)
&gt;&gt;&gt; lf = model.makeLikelihoodFunction(tree, bins=4)
&gt;&gt;&gt; lf.setParamRule(<span class="py_string">'bprobs'</span>, is_const=<span class="py_keyword">True</span>)
&gt;&gt;&gt; lf.setAlignment(aln3)
&gt;&gt;&gt; lf.optimise(local=<span class="py_keyword">True</span>, max_restarts=2, show_progress = <span class="py_keyword">False</span>)</pre></div>
<div class="section">
<h2><a class="toc-backref" href="#id43" id="likelihood-analysis-of-multiple-loci" name="likelihood-analysis-of-multiple-loci">Likelihood analysis of multiple loci</a></h2>
<p>We want to know whether an exchangeability parameter is different between alignments. We will specify a null model, under which each alignment get's it's own motif probabilities and all alignments share branch lengths and the exchangeability parameter kappa (the transition / transversion ratio). We'll split the example alignment into two-pieces.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs, LoadTree
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.evolve.models <span class="py_keyword">import</span> HKY85
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.recalculation.scope <span class="py_keyword">import</span> EACH, ALL
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.maths.stats <span class="py_keyword">import</span> chisqprob
&gt;&gt;&gt; aln = LoadSeqs(<span class="py_string">"data/long_testseqs.fasta"</span>)
&gt;&gt;&gt; half = len(aln)/2
&gt;&gt;&gt; aln1 = aln[:half]
&gt;&gt;&gt; aln2 = aln[half:]</pre><p>We provide names for those alignments, then construct the tree, model instances.</p>
<pre class="code">&gt;&gt;&gt; loci_names = [<span class="py_string">"1st-half"</span>, <span class="py_string">"2nd-half"</span>]
&gt;&gt;&gt; loci = [aln1, aln2]
&gt;&gt;&gt; tree = LoadTree(tip_names=aln.getSeqNames())
&gt;&gt;&gt; mod = HKY85()</pre><p>To make a likelihood function with multiple alignments we provide the list of loci names. We can then specify a parameter (other than length) to be the same across the loci (using the imported <tt class="docutils literal"><span class="pre">ALL</span></tt>) or different for each locus (using <tt class="docutils literal"><span class="pre">EACH</span></tt>). We conduct a LR test as before.</p>
<pre class="code">&gt;&gt;&gt; lf = mod.makeLikelihoodFunction(tree, loci=loci_names)
&gt;&gt;&gt; lf.setParamRule(<span class="py_string">"length"</span>, is_independent=<span class="py_keyword">False</span>)
&gt;&gt;&gt; lf.setParamRule(<span class="py_string">'kappa'</span>, loci = ALL)
&gt;&gt;&gt; lf.setAlignment(loci)
&gt;&gt;&gt; lf.optimise(local=<span class="py_keyword">True</span>, show_progress=<span class="py_keyword">False</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> lf
Likelihood Function Table
===========================
  locus    motif    mprobs
---------------------------
1st-half        T    0.2341
1st-half        C    0.1758
1st-half        A    0.3956
1st-half        G    0.1944
2nd-half        T    0.2400
2nd-half        C    0.1851
2nd-half        A    0.3628
2nd-half        G    0.2121
---------------------------
================
kappa    length
----------------
8.0072    0.0271
----------------
&gt;&gt;&gt; all_lnL = lf.getLogLikelihood()
&gt;&gt;&gt; all_nfp = lf.getNumFreeParams()
&gt;&gt;&gt; lf.setParamRule(<span class="py_string">'kappa'</span>, loci = EACH)
&gt;&gt;&gt; lf.optimise(local=<span class="py_keyword">True</span>, show_progress=<span class="py_keyword">False</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> lf
Likelihood Function Table
==================
   locus     kappa
------------------
1st-half    7.9077
2nd-half    8.1293
------------------
===========================
   locus    motif    mprobs
---------------------------
1st-half        T    0.2341
1st-half        C    0.1758
1st-half        A    0.3956
1st-half        G    0.1944
2nd-half        T    0.2400
2nd-half        C    0.1851
2nd-half        A    0.3628
2nd-half        G    0.2121
---------------------------
======
length
------
0.0271
------
&gt;&gt;&gt; each_lnL = lf.getLogLikelihood()
&gt;&gt;&gt; each_nfp = lf.getNumFreeParams()
&gt;&gt;&gt; LR = 2 * (each_lnL - all_lnL)
&gt;&gt;&gt; df = each_nfp - all_nfp
&gt;&gt;&gt; <span class="py_keyword">print</span> LR, df, chisqprob(LR, df)
0.00424532328725 1 0.94804967777</pre></div>
<div class="section">
<h2><a class="toc-backref" href="#id44" id="reusing-results-to-speed-up-optimisation" name="reusing-results-to-speed-up-optimisation">Reusing results to speed up optimisation</a></h2>
<p>An example of how to use the maximum-likelihood parameter estimates from one model as starting values for another model. In this file we do something silly, by saving a result and then reloading it. This is silly because the analyses are run consecutively. A better approach when running consecutively is to simply use the annotated tree directly.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs, LoadTree
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.evolve.models <span class="py_keyword">import</span> Y98</pre><p>We'll create a simple model, optimise it and save it for later reuse</p>
<pre class="code">&gt;&gt;&gt; al = LoadSeqs(<span class="py_string">"data/test.paml"</span>)
&gt;&gt;&gt; t = LoadTree(<span class="py_string">"data/test.tree"</span>)
&gt;&gt;&gt; sm = Y98()
&gt;&gt;&gt; lf = sm.makeLikelihoodFunction(t)
&gt;&gt;&gt; lf.setAlignment(al)
&gt;&gt;&gt; lf.optimise(local=<span class="py_keyword">True</span>, show_progress=<span class="py_keyword">False</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> lf
Likelihood Function Table
================
 kappa     omega
----------------
9.2759    1.8713
----------------
=============================
     edge    parent    length
-----------------------------
    Human    edge.0    0.0968
HowlerMon    edge.0    0.0540
   edge.0    edge.1    0.0654
    Mouse    edge.1    0.9116
   edge.1      root    0.0000
NineBande      root    0.1073
 DogFaced      root    0.1801...</pre><p>The essential object for reuse is an annotated tree these capture the parameter estimates from the above optimisation we can either use this directly in the same run, or we can save the tree to file in <tt class="docutils literal"><span class="pre">xml</span></tt> format and reload the tree at a later time for use. In this example I'll illustrate the latter scenario.</p>
<pre class="code">&gt;&gt;&gt; at=lf.getAnnotatedTree()
&gt;&gt;&gt; at.writeToFile(<span class="py_string">'tree.xml'</span>)</pre><p>We load the tree as per usual</p>
<pre class="code">&gt;&gt;&gt; nt = LoadTree(<span class="py_string">'tree.xml'</span>)</pre><p>Now create a more parameter rich model, in this case by allowing the <tt class="docutils literal"><span class="pre">Human</span></tt> edge to have a different value of <tt class="docutils literal"><span class="pre">omega</span></tt>. By providing the annotated tree, the parameter estimates from the above run will be used as starting values for the new model.</p>
<pre class="code">&gt;&gt;&gt; new_lf = sm.makeLikelihoodFunction(nt)
&gt;&gt;&gt; new_lf.setParamRule(<span class="py_string">'omega'</span>, edge=<span class="py_string">'Human'</span>,
... is_independent=<span class="py_keyword">True</span>)
&gt;&gt;&gt; new_lf.setAlignment(al)
&gt;&gt;&gt; new_lf.optimise(local=<span class="py_keyword">True</span>, show_progress=<span class="py_keyword">False</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> new_lf
Likelihood Function Table
======
 kappa
------
9.0706
------
============================================
     edge    parent    length          omega
--------------------------------------------
    Human    edge.0    0.1001    999999.9965
HowlerMon    edge.0    0.0510         1.5666
   edge.0    edge.1    0.0649         1.5666
    Mouse    edge.1    0.8984         1.5666
   edge.1      root    0.0000         1.5666
NineBande      root    0.1064         1.5666
 DogFaced      root    0.1793         1.5666...</pre><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">A parameter rich model applied to a small data set is unreliable.</td>
</tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id45" id="specifying-and-using-an-restricted-nucleotide-substitution-model" name="specifying-and-using-an-restricted-nucleotide-substitution-model">Specifying and using an restricted nucleotide substitution model</a></h2>
<p>Do standard <tt class="docutils literal"><span class="pre">cogent</span></tt> imports.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs, LoadTree, DNA
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.evolve.predicate <span class="py_keyword">import</span> MotifChange
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.evolve.substitution_model <span class="py_keyword">import</span> Nucleotide</pre><p>To specify substitution models we use the <tt class="docutils literal"><span class="pre">MotifChange</span></tt> class from predicates. In the case of an unrestricted nucleotide model, we specify 11 such <tt class="docutils literal"><span class="pre">MotifChanges</span></tt>, the last possible change being ignored (with the result it is constrained to equal 1, thus calibrating the matrix).</p>
<pre class="code">&gt;&gt;&gt; ACTG = list(<span class="py_string">'ACTG'</span>)
&gt;&gt;&gt; preds = [MotifChange(i, j, forward_only=<span class="py_keyword">True</span>) <span class="py_keyword">for</span> i <span class="py_keyword">in</span> ACTG <span class="py_keyword">for</span> j <span class="py_keyword">in</span> ACTG <span class="py_keyword">if</span> i != j]
&gt;&gt;&gt; <span class="py_keyword">del</span>(preds[-1])
&gt;&gt;&gt; preds
[A&gt;C, A&gt;T, A&gt;G, C&gt;A, C&gt;T, C&gt;G, T&gt;A, T&gt;C, T&gt;G, G&gt;A, G&gt;C]
&gt;&gt;&gt; sm = Nucleotide(predicates=preds, recode_gaps=<span class="py_keyword">True</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> sm

Nucleotide ( name = <span class="py_string">''</span>; type = <span class="py_string">'None'</span>; params = [<span class="py_string">'A&gt;T'</span>, <span class="py_string">'C&gt;G'</span>, <span class="py_string">'T&gt;G'</span>, <span class="py_string">'G&gt;A'</span>, <span class="py_string">'T&gt;A'</span>, <span class="py_string">'T&gt;C'</span>, <span class="py_string">'C&gt;A'</span>, <span class="py_string">'G&gt;C'</span>, <span class="py_string">'C&gt;T'</span>, <span class="py_string">'A&gt;G'</span>, <span class="py_string">'A&gt;C'</span>]; number of motifs = 4; motifs = [<span class="py_string">'T'</span>, <span class="py_string">'C'</span>, <span class="py_string">'A'</span>, <span class="py_string">'G'</span>])
</pre><p>We'll illustrate this with a sample alignment and tree in &quot;data/test.paml&quot;.</p>
<pre class="code">&gt;&gt;&gt; tr = LoadTree(<span class="py_string">"data/test.tree"</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> tr
(((Human,HowlerMon),Mouse),NineBande,DogFaced);
&gt;&gt;&gt; al = LoadSeqs(<span class="py_string">"data/test.paml"</span>, moltype=DNA)
&gt;&gt;&gt; al
5 x 60 dna alignment: NineBande[GCAAGGCGCCA...], Mouse[GCAGTGAGCCA...], Human[GCAAGGAGCCA...], ...</pre><p>We now construct the parameter controller with each predicate constant across the tree, and get the likelihood function calculator.</p>
<pre class="code">&gt;&gt;&gt; lf = sm.makeLikelihoodFunction(tr)
&gt;&gt;&gt; lf.setAlignment(al)
&gt;&gt;&gt; lf.setName(<span class="py_string">'Unrestricted model'</span>)
&gt;&gt;&gt; lf.optimise()
Outer loop = 0...</pre><p>In the output from the <tt class="docutils literal"><span class="pre">optimise</span></tt> call you'll see progress from the simulated annealing optimiser which is used first, and the Powell optimiser which finishes things off.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> lf
Unrestricted model
============================================================================
   A&gt;C       A&gt;G       A&gt;T       C&gt;A       C&gt;G       C&gt;T       G&gt;A       G&gt;C
----------------------------------------------------------------------------
0.6890    1.8880    0.0000    0.0000    0.0000    2.1652    0.2291    0.4868
----------------------------------------------------------------------------

continued:
====================================
   A&gt;C       T&gt;A       T&gt;C       T&gt;G
------------------------------------
0.6890    0.0000    2.2755    0.0000
------------------------------------

=============================
     edge    parent    length
-----------------------------
    Human    edge.0    0.0333
HowlerMon    edge.0    0.0165
   edge.0    edge.1    0.0164
    Mouse    edge.1    0.1980
   edge.1      root    0.0000
NineBande      root    0.0335
 DogFaced      root    0.0503
-----------------------------
===============
motif    mprobs
---------------
    T    0.1433
    C    0.1600
    A    0.3800
    G    0.3167
---------------</pre><p>This data set is very small, so the parameter estimates are poor and hence doing something like allowing the parameters to differ between edges is silly. <strong>But</strong> if you have lots of data it makes sense and can be specified by modifying the <tt class="docutils literal"><span class="pre">lf</span></tt> as follows.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">for</span> pred <span class="py_keyword">in</span> preds:
...     lf.setParamRule(str(pred), is_independent=<span class="py_keyword">True</span>)</pre><p>You then make a new <tt class="docutils literal"><span class="pre">lf</span></tt> and optimise as above, but I won't do that now as the optimiser would struggle due to the low information content of this sample.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id46" id="simulate-an-alignment" name="simulate-an-alignment">Simulate an alignment</a></h2>
<p>How to  simulate an alignment. For this example we just create a simple model using a four taxon tree with very different branch lengths, a Felsenstein model with very different nucleotide frequencies and a long alignment.</p>
<p>See the other examples for how to define other substitution models.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">import</span> sys
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadTree
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.evolve <span class="py_keyword">import</span> substitution_model</pre><p>Specify the 4 taxon tree,</p>
<pre class="code">&gt;&gt;&gt; t = LoadTree(treestring=<span class="py_string">'(a:0.4,b:0.3,(c:0.15,d:0.2)edge.0:0.1);'</span>)</pre><p>Define our Felsenstein 1981 substitution model.</p>
<pre class="code">&gt;&gt;&gt; sm = substitution_model.Nucleotide(motif_probs = {<span class="py_string">'A'</span>: 0.5, <span class="py_string">'C'</span>: 0.2,
... <span class="py_string">'G'</span>: 0.2, <span class="py_string">'T'</span>: 0.1}, model_gaps=<span class="py_keyword">False</span>)
&gt;&gt;&gt; lf = sm.makeLikelihoodFunction(t)
&gt;&gt;&gt; lf.setConstantLengths()
&gt;&gt;&gt; lf.setName(<span class="py_string">'F81 model'</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> lf
F81 model
==========================
  edge    parent    length
--------------------------
     a      root    0.4000
     b      root    0.3000
     c    edge.0    0.1500
     d    edge.0    0.2000
edge.0      root    0.1000
--------------------------
===============
motif    mprobs
---------------
    T    0.1000
    C    0.2000
    A    0.5000
    G    0.2000
---------------</pre><p>We'll now create a simulated alignment of length 1000 nucleotides.</p>
<pre class="code">&gt;&gt;&gt; simulated = lf.simulateAlignment(sequence_length=1000)</pre><p>The result is a normal <tt class="docutils literal"><span class="pre">Cogent</span></tt> alignment object, which can be used in the same way as any other alignment object.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id47" id="performing-a-parametric-bootstrap" name="performing-a-parametric-bootstrap">Performing a parametric bootstrap</a></h2>
<p>This file contains an example for estimating the probability of a Likelihood ratio statistic obtained from a relative rate test. The bootstrap classes can take advantage of parallel architectures.</p>
<p>From cogent import all the components we need.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs, LoadTree
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.evolve <span class="py_keyword">import</span> bootstrap
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.evolve.models <span class="py_keyword">import</span> HKY85
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.maths <span class="py_keyword">import</span> stats</pre><p>Define the null model that takes an alignment object and returns a likelihood function properly assembled for optimising the likelihood under the null hypothesis. The sample distribution is generated using this model.</p>
<p>We will use a HKY model.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">def</span> <span class="py_identifier">create_alt_function</span>():
...     t = LoadTree(<span class="py_string">"data/test.tree"</span>)
...     sm = HKY85()
...     <span class="py_keyword">return</span> sm.makeLikelihoodFunction(t)</pre><p>Define a function that takes an alignment object and returns an appropriately assembled function for the alternative model. Since the two models are identical bar the constraint on the branch lengths, we'll use the same code to generate the basic likelihood function as for the alt model, and then apply the constraint here</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">def</span> <span class="py_identifier">create_null_function</span>():
...     lf = create_alt_function()
...     <span class="py_comment"># set the local clock for humans &amp; howler monkey</span>
...     lf.setLocalClock(<span class="py_string">"Human"</span>, <span class="py_string">"HowlerMon"</span>)
...     <span class="py_keyword">return</span> lf</pre><p>Get our observed data alignment</p>
<pre class="code">&gt;&gt;&gt; aln = LoadSeqs(filename = <span class="py_string">"data/test.paml"</span>)</pre><p>Create a <tt class="docutils literal"><span class="pre">EstimateProbability</span></tt> bootstrap instance</p>
<pre class="code">&gt;&gt;&gt; estimateP = bootstrap.EstimateProbability(create_null_function(),
...                                       create_alt_function(),
...                                       aln)</pre><p>Specify how many random samples we want it to generate. Here we use a very small number of replicates only for the purpose of testing.</p>
<pre class="code">&gt;&gt;&gt; estimateP.setNumReplicates(5)</pre><p>Run it.</p>
<pre class="code">&gt;&gt;&gt; estimateP.run(show_progress = <span class="py_keyword">False</span>)</pre><p><tt class="docutils literal"><span class="pre">show_progress</span></tt> sets whether individual optimisations are printed to screen. Get the estimated probability.</p>
<pre class="code">&gt;&gt;&gt; p = estimateP.getEstimatedProb()</pre><p><tt class="docutils literal"><span class="pre">p</span></tt> is a floating point value, as you'd expect. Grab the estimated likelihoods for the observed data.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> <span class="py_string">'%.2f, %.2f'</span> % estimateP.getObservedlnL()
-162.65, -162.48</pre></div>
<div class="section">
<h2><a class="toc-backref" href="#id48" id="estimate-parameter-values-using-a-sampling-from-a-dataset" name="estimate-parameter-values-using-a-sampling-from-a-dataset">Estimate parameter values using a sampling from a dataset</a></h2>
<p>This script uses the sample method of the alignment class to provide an
estimate for a two stage optimisation.
This allows rapid optimisation of long alignments and complex models with
a good chance of arriving at the global maximum for the model and data.
Local optimisation of the full alignment may end up in local maximum and
for this reason results from this strategy my be inaccurate.</p>
<p>From cogent import all the components we need.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs, LoadTree
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.evolve <span class="py_keyword">import</span>  substitution_model</pre><p>Load your alignment, note that if your file ends with a suffix that is the same as it's format (assuming it's a supported format) then you can just give the filename. Otherwise you can specify the format using the format argument.</p>
<pre class="code">&gt;&gt;&gt; al = LoadSeqs(filename = <span class="py_string">"data/test.paml"</span>)</pre><p>Get your tree</p>
<pre class="code">&gt;&gt;&gt; t = LoadTree(filename = <span class="py_string">"data/test.tree"</span>)</pre><p>Get the raw substitution model</p>
<pre class="code">&gt;&gt;&gt; sm = substitution_model.Nucleotide()</pre><p>Make a likelihood function from a sample of the alignment the .sample method selects the chosen number of bases at random because we set motif probabilities earlier the motif probabilities of the whole alignment rather than the sample will be used for the calculator</p>
<pre class="code">&gt;&gt;&gt; lf = sm.makeLikelihoodFunction(t)
&gt;&gt;&gt; lf.setMotifProbsFromData(al)
&gt;&gt;&gt; lf.setAlignment(al.sample(20))</pre><p>Optimise with the slower but more accurate simulated annealing optimiser</p>
<pre class="code">&gt;&gt;&gt; lf.optimise()
Outer loop = 0...</pre><p>Next use the whole alignment</p>
<pre class="code">&gt;&gt;&gt; lf.setAlignment(al)</pre><p>and the faster Powell optimiser that will only find the best result near the provided starting point</p>
<pre class="code">&gt;&gt;&gt; lf.optimise(local=<span class="py_keyword">True</span>)
Number of function evaluations = 1; current F = ...</pre><p>Print the result using <tt class="docutils literal"><span class="pre">print</span> <span class="pre">lf</span></tt>.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id49" id="phylogenetic-reconstruction" name="phylogenetic-reconstruction">Phylogenetic Reconstruction</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id50" id="calculate-pairwise-distances-between-sequences" name="calculate-pairwise-distances-between-sequences">Calculate pairwise distances between sequences</a></h2>
<p>An example of how to calculate the pairwise distances for a set of sequences.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.phylo <span class="py_keyword">import</span> distance</pre><p>Import a substitution model (or create your own)</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.evolve.models <span class="py_keyword">import</span> HKY85</pre><p>Load my alignment</p>
<pre class="code">&gt;&gt;&gt; al = LoadSeqs(<span class="py_string">"data/test.paml"</span>)</pre><p>Create a pairwise distances object with your alignment and substitution model</p>
<pre class="code">&gt;&gt;&gt; d = distance.EstimateDistances(al, submodel= HKY85())</pre><p>Printing <tt class="docutils literal"><span class="pre">d</span></tt> before execution shows its status.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> d
=========================================================================
Seq1 \ Seq2    NineBande       Mouse       Human    HowlerMon    DogFaced
-------------------------------------------------------------------------
  NineBande            *    Not Done    Not Done     Not Done    Not Done
      Mouse     Not Done           *    Not Done     Not Done    Not Done
      Human     Not Done    Not Done           *     Not Done    Not Done
  HowlerMon     Not Done    Not Done    Not Done            *    Not Done
   DogFaced     Not Done    Not Done    Not Done     Not Done           *
-------------------------------------------------------------------------</pre><p>Which in this case is to simply indicate nothing has been done.</p>
<pre class="code">&gt;&gt;&gt; d.run(show_progress=<span class="py_keyword">False</span>)
&gt;&gt;&gt; <span class="py_keyword">print</span> d
=====================================================================
Seq1 \ Seq2    NineBande     Mouse     Human    HowlerMon    DogFaced
---------------------------------------------------------------------
  NineBande            *    0.2196    0.0890       0.0700      0.0891
      Mouse       0.2196         *    0.2737       0.2736      0.2467
      Human       0.0890    0.2737         *       0.0530      0.1092
  HowlerMon       0.0700    0.2736    0.0530            *      0.0894
   DogFaced       0.0891    0.2467    0.1092       0.0894           *
---------------------------------------------------------------------</pre><p>Note that pairwise distances can be distributed for computation across multiple CPU's. In this case, when statistics (like distances) are requested only the master CPU returns data.</p>
<p>We'll write a phylip formatted distance matrix.</p>
<pre class="code">&gt;&gt;&gt; d.writeToFile(<span class="py_string">'junk.phylip'</span>, format=<span class="py_string">"phylip"</span>)</pre><p>We'll also save the distances to file in Python's pickle format.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">import</span> cPickle
&gt;&gt;&gt; f = open(<span class="py_string">'dists_for_phylo.pickle'</span>, <span class="py_string">"w"</span>)
&gt;&gt;&gt; cPickle.dump(d.getPairwiseDistances(), f)
&gt;&gt;&gt; f.close()</pre></div>
<div class="section">
<h2><a class="toc-backref" href="#id51" id="make-a-neighbor-joining-tree" name="make-a-neighbor-joining-tree">Make a neighbor joining tree</a></h2>
<p>An example of how to calculate the pairwise distances for a set of sequences.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.phylo <span class="py_keyword">import</span> distance, nj</pre><p>Import a substitution model (or create your own)</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.evolve.models <span class="py_keyword">import</span> HKY85</pre><p>Load the alignment.</p>
<pre class="code">&gt;&gt;&gt; al = LoadSeqs(<span class="py_string">"data/test.paml"</span>)</pre><p>Create a pairwise distances object calculator for the alignment, providing a substitution model instance.</p>
<pre class="code">&gt;&gt;&gt; d = distance.EstimateDistances(al, submodel= HKY85())
&gt;&gt;&gt; d.run(show_progress=<span class="py_keyword">False</span>)</pre><p>Now use this matrix to build a neighbour joining tree.</p>
<pre class="code">&gt;&gt;&gt; mytree = nj.nj(d.getPairwiseDistances())
&gt;&gt;&gt; <span class="py_keyword">print</span> mytree.asciiArt()
          /-NineBande
         |
         |          /-DogFaced
         |-edge.1--|
-root----|         |          /-HowlerMon
         |          \edge.0--|
         |                    \-Human
         |
          \-Mouse</pre><p>We can save this tree to file.</p>
<pre class="code">&gt;&gt;&gt; mytree.writeToFile(<span class="py_string">'test_nj.tree'</span>)</pre></div>
<div class="section">
<h2><a class="toc-backref" href="#id52" id="phylogenetic-reconstruction-by-least-squares" name="phylogenetic-reconstruction-by-least-squares">Phylogenetic reconstruction by least squares</a></h2>
<p>We will load some pre-computed pairwise distance data. To see how that data was computed see the calculating pairwise distances example. That data is saved in a format called <tt class="docutils literal"><span class="pre">pickle</span></tt> which is native to python. As per usual, we import the basic components we need.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">import</span> cPickle
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.phylo <span class="py_keyword">import</span> distance, least_squares</pre><p>Now load the distance data.</p>
<pre class="code">&gt;&gt;&gt; filename = <span class="py_string">"dists_for_phylo.pickle"</span>
&gt;&gt;&gt; f = file(filename, <span class="py_string">'r'</span>)
&gt;&gt;&gt; dists = cPickle.load(f)
&gt;&gt;&gt; f.close()</pre><p>If there are extremely small distances, they can cause an error in the least squares calculation. Since such estimates are between extremely closely related sequences we could simply drop all distances for one of the sequences. We won't do that here, we'll leave that as exercise.</p>
<p>We make the ls calculator.</p>
<pre class="code">&gt;&gt;&gt; ls = least_squares.WLS(dists)</pre><p>We will search tree space for the collection of best trees using the advanced stepwise addition algorithm (hereafter <em>asaa</em>).</p>
<div class="section">
<h3><a class="toc-backref" href="#id53" id="look-for-the-single-best-tree" name="look-for-the-single-best-tree">Look for the single best tree</a></h3>
<p>In this use case we are after just 1 tree. We specify up to what taxa size all possible trees for the sample will be computed. Here we are specifying <tt class="docutils literal"><span class="pre">a=5</span></tt>. This means 5 sequences will be picked randomly and all possible trees relating them will be evaluated. <tt class="docutils literal"><span class="pre">k=1</span></tt> means only the best tree will be kept at the end of each such round of evaluation. For every remaining sequence it is grafted onto every possible branch of this tree. The best <tt class="docutils literal"><span class="pre">k</span></tt> results are then taken to the next round, when another sequence is randomly selected for addition. This proceeds until all sequences have been added. The result with following arguments is a single wls score and a single <tt class="docutils literal"><span class="pre">Tree</span></tt> which can be saved etc ..</p>
<pre class="code">&gt;&gt;&gt; score, tree = ls.trex(a = 5, k = 1, show_progress = <span class="py_keyword">True</span>)
3 trees of size 4 at start
15 trees of size 5 ... done
&gt;&gt;&gt; <span class="py_keyword">print</span> score
0.0009...</pre><p>We won't display this tree, because we are doing more below.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id54" id="a-more-rigourous-tree-space-search" name="a-more-rigourous-tree-space-search">A more rigourous tree space search</a></h3>
<p>We change the asaa settings, so we keep more trees and then look at the distribution of the statistics for the last collection of trees. We could also change <tt class="docutils literal"><span class="pre">a</span></tt> to be larger, but in the current case we just adjust <tt class="docutils literal"><span class="pre">k</span></tt>. We also set the argument <tt class="docutils literal"><span class="pre">return_all</span> <span class="pre">=</span> <span class="pre">True</span></tt>, the effect of which is to return the complete set of 145 trees. These, and their support statistic, can then be inspected.</p>
<pre class="code">&gt;&gt;&gt; trees = ls.trex(a = 5, k = 5, show_progress = <span class="py_keyword">True</span>, return_all = <span class="py_keyword">True</span>)
3 trees of size 4 at start
15 trees of size 5 ... done</pre><p>Remember the sum-of-squares statistic will be smaller for 'good' trees. The order of the trees returned is from good to bad. As indicated above, <tt class="docutils literal"><span class="pre">trees</span></tt> has length 145.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> len(trees)
15</pre><p>Lets inspect the resulting statistics. First, the object <tt class="docutils literal"><span class="pre">trees</span></tt> is a list of (wls, Tree) tuples. We will therefore loop over the list to generate a separate list of just the wls statistics. The following syntax is called a list comprehension - basically just a very succinct <tt class="docutils literal"><span class="pre">for</span></tt> loop.</p>
<pre class="code">&gt;&gt;&gt; wls_stats = [tree[0] <span class="py_keyword">for</span> tree <span class="py_keyword">in</span> trees]
&gt;&gt;&gt; <span class="py_keyword">print</span> wls_stats[:15]
[0.000914409229523, 0.001...</pre><p>From this you'll see that the first 5 results are very similar to each other and would probably reasonably be considered equivalently supported topologies. I'll just print the first two of the these trees after balancing them (in order to make their representations as equal as possible).</p>
<pre class="code">&gt;&gt;&gt; t1 = trees[0][1].balanced()
&gt;&gt;&gt; t2 = trees[1][1].balanced()
&gt;&gt;&gt; <span class="py_keyword">print</span> t1.asciiArt()
          /-DogFaced
         |
         |          /-NineBande
-root----|-edge.0--|
         |          \-Mouse
         |
         |          /-HowlerMon
          \edge.1--|
                    \-Human
&gt;&gt;&gt; <span class="py_keyword">print</span> t2.asciiArt()
          /-NineBande
         |
         |          /-DogFaced
-root----|-edge.0--|
         |          \-Mouse
         |
         |          /-HowlerMon
          \edge.1--|
                    \-Human</pre><p>You can see the difference involves the Jackrabbit, TreeShrew, Gorilla, Rat clade.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id55" id="assessing-the-fit-for-a-pre-specified-tree-topology" name="assessing-the-fit-for-a-pre-specified-tree-topology">Assessing the fit for a pre-specified tree topology</a></h3>
<p>In some instances we may have a tree from the literature or elsewhere whose fit to the data we seek to evaluate. In this case I'm going load a tree as follows.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadTree
&gt;&gt;&gt; query_tree = LoadTree(treestring = <span class="py_string">"((Human:.2,DogFaced:.2):.3,(NineBande:.1, Mouse:.5):.2,HowlerMon:.1)"</span>)</pre><p>We now just use the <tt class="docutils literal"><span class="pre">ls</span></tt> object created above. The following evaluates the query using it's associated branch lengths, returning only the wls statistic.</p>
<pre class="code">&gt;&gt;&gt; ls.evaluateTree(query_tree)
 3.95...</pre><p>We can also evaluate just the tree's topology, returning both the wls statistic and the tree with best fit branch lengths.</p>
<pre class="code">&gt;&gt;&gt; ls.evaluateTopology(query_tree)
(0.00316480233404, Tree(<span class="py_string">"((Human,DogFaced),(NineBande,Mouse),HowlerMon)root;"</span>))</pre></div>
<div class="section">
<h3><a class="toc-backref" href="#id56" id="using-maximum-likelihood-for-measuring-tree-fit" name="using-maximum-likelihood-for-measuring-tree-fit">Using maximum likelihood for measuring tree fit</a></h3>
<p>This is a much slower algorithm and the interface largely mirrors that for the above. The difference is you import <tt class="docutils literal"><span class="pre">maximum_likelihood</span></tt> instead of <tt class="docutils literal"><span class="pre">least_squares</span></tt>, and use the <tt class="docutils literal"><span class="pre">ML</span></tt> instead of <tt class="docutils literal"><span class="pre">WLS</span></tt> classes. The <tt class="docutils literal"><span class="pre">ML</span></tt> class requires a substitution model (like a HKY85 for DNA or JTT92 for protein), and an alignment. It also optionally takes a distance matrix, such as that used here, computed for the same sequences. These distances are then used to obtain estimates of branch lengths by the WLS method for each evaluated tree topology which are then used as starting values for the likelihood optimisation.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id57" id="making-a-phylogenetic-tree-from-a-protein-sequence-alignment" name="making-a-phylogenetic-tree-from-a-protein-sequence-alignment">Making a phylogenetic tree from a protein sequence alignment</a></h2>
<p>In this example we pull together the distance calculation and tree building with the additional twist of using an empirical protein substitution matrix. We will therefore be computing the tree from a protein sequence alignment. We will first do the standard cogent import for <tt class="docutils literal"><span class="pre">LoadSeqs</span></tt>.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent <span class="py_keyword">import</span> LoadSeqs, PROTEIN</pre><p>We will use an empirical protein substitution matrix, this requires a file format parser also.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.evolve.substitution_model <span class="py_keyword">import</span> EmpiricalProteinMatrix
&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.parse.paml_matrix <span class="py_keyword">import</span> PamlMatrixParser</pre><p>The next components we need are for computing the matrix of pairwise sequence distances and then for estimating a neighbour joining tree from those distances.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">from</span> cogent.phylo <span class="py_keyword">import</span> nj, distance</pre><p>Now load our sequence alignment, explicitly setting the alphabet to be protein.</p>
<pre class="code">&gt;&gt;&gt; aln = LoadSeqs(<span class="py_string">'data/abglobin_aa.phylip'</span>, interleaved=<span class="py_keyword">True</span>,
...                 moltype=PROTEIN)</pre><p>We open the file that contains the empirical matrix and parse the matrix and frequencies.</p>
<pre class="code">&gt;&gt;&gt; matrix_file = open(<span class="py_string">'data/dayhoff.dat'</span>)</pre><p>Create an Empirical Protein Matrix Substitution model object. This will take the unscaled empirical matrix and use it and the motif frequencies to create a scaled Q matrix.</p>
<pre class="code">&gt;&gt;&gt; sm = EmpiricalProteinMatrix(*PamlMatrixParser(matrix_file))</pre><p>We now use this and the alignment to construct a distance calculator.</p>
<pre class="code">&gt;&gt;&gt; d = distance.EstimateDistances(aln, submodel = sm)
&gt;&gt;&gt; d.run(show_progress=<span class="py_keyword">False</span>)</pre><p>The resulting distances are passed to the nj function.</p>
<pre class="code">&gt;&gt;&gt; mytree = nj.nj(d.getPairwiseDistances())</pre><p>The shape of the resulting tree can be readily view using the <tt class="docutils literal"><span class="pre">asciiArt</span></tt> method on <tt class="docutils literal"><span class="pre">Tree</span></tt>.</p>
<pre class="code">&gt;&gt;&gt; <span class="py_keyword">print</span> mytree.asciiArt()
          /-human
         |
         |          /-rabbit
-root----|-edge.1--|
         |          \-rat
         |
         |          /-goat-cow
          \edge.0--|
                    \-marsupial</pre><p>This tree can be saved to file, the <tt class="docutils literal"><span class="pre">with_distances</span></tt> argument specifies that branch lengths are to be included in the newick formatted output.</p>
<pre class="code">&gt;&gt;&gt; mytree.writeToFile(<span class="py_string">'test_nj.tree'</span>, with_distances=<span class="py_keyword">True</span>)</pre></div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id58" id="python-coding-guidelines" name="python-coding-guidelines">Python Coding Guidelines</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id59" id="why-have-coding-guidelines" name="why-have-coding-guidelines">Why have coding guidelines?</a></h2>
<p>As project size increases, consistency increases in importance. Unit testing and a consistent style are critical to having trusted code to integrate. Also, guesses about names and interfaces will be correct more often.</p>
<div class="section">
<h3><a class="toc-backref" href="#id60" id="what-should-i-call-my-variables" name="what-should-i-call-my-variables">What should I call my variables?</a></h3>
<ul class="simple">
<li><em>Choose the name that people will most likely guess.</em> Make it descriptive, but not too long: <tt class="docutils literal"><span class="pre">curr_record</span></tt> is better than <tt class="docutils literal"><span class="pre">c</span></tt>, or <tt class="docutils literal"><span class="pre">curr</span></tt>, or <tt class="docutils literal"><span class="pre">current_genbank_record_from_database</span></tt>.</li>
<li><em>Good names are hard to find.</em> Don't be afraid to change names except when they are part of interfaces that other people are also using. It may take some time working with the code to come up with reasonable names for everything: if you have unit tests, it's easy to change them, especially with global search and replace.</li>
<li><em>Use singular names for individual things, plural names for collections.</em> For example, you'd expect <tt class="docutils literal"><span class="pre">self.Name</span></tt> to hold something like a single string, but <tt class="docutils literal"><span class="pre">self.Names</span></tt> to hold something that you could loop through like a list or dict. Sometimes the decision can be tricky: is <tt class="docutils literal"><span class="pre">self.Index</span></tt> an int holding a positon, or a dict holding records keyed by name for easy lookup? If you find yourself wondering these things, the name should probably be changed to avoid the problem: try <tt class="docutils literal"><span class="pre">self.Position</span></tt> or <tt class="docutils literal"><span class="pre">self.LookUp</span></tt>.</li>
<li><em>Don't make the type part of the name.</em> You might want to change the implementation later. Use <tt class="docutils literal"><span class="pre">Records</span></tt> rather than <tt class="docutils literal"><span class="pre">RecordDict</span></tt> or <tt class="docutils literal"><span class="pre">RecordList</span></tt>, etc. Don't use Hungarian Notation either (i.e. where you prefix the name with the type).</li>
<li><em>Make the name as precise as possible.</em> If the variable is the name of the input file, call it <tt class="docutils literal"><span class="pre">infile_name</span></tt>, not <tt class="docutils literal"><span class="pre">input</span></tt> or <tt class="docutils literal"><span class="pre">file</span></tt> (which you shouldn't use anyway, since they're keywords), and not <tt class="docutils literal"><span class="pre">infile</span></tt> (because that looks like it should be a file object, not just its name).</li>
<li><em>Use</em> <tt class="docutils literal"><span class="pre">result</span></tt> <em>to store the value that will be returned from a method or function.</em> Use <tt class="docutils literal"><span class="pre">data</span></tt> for input in cases where the function or method acts on arbitrary data (e.g. sequence data, or a list of numbers, etc.) unless a more descriptive name is appropriate.</li>
<li><em>One-letter variable names should only occur in math functions or as loop iterators with limited scope.</em> Limited scope covers things like <tt class="docutils literal"><span class="pre">for</span> <span class="pre">k</span> <span class="pre">in</span> <span class="pre">keys:</span> <span class="pre">print</span> <span class="pre">k</span></tt>, where <tt class="docutils literal"><span class="pre">k</span></tt> survives only a line or two. Loop iterators should refer to the variable that they're looping through: <tt class="docutils literal"><span class="pre">for</span> <span class="pre">k</span> <span class="pre">in</span> <span class="pre">keys,</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">items</span></tt>, or <tt class="docutils literal"><span class="pre">for</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">keys,</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">items</span></tt>. If the loop is long or there are several 1-letter variables active in the same scope, rename them.</li>
<li><em>Limit your use of abbreviations.</em> A few well-known abbreviations are OK, but you don't want to come back to your code in 6 months and have to figure out what <tt class="docutils literal"><span class="pre">sptxck2</span></tt> is. It's worth it to spend the extra time typing <tt class="docutils literal"><span class="pre">species_taxon_check_2</span></tt>, but that's still a horrible name: what's check number 1? Far better to go with something like <tt class="docutils literal"><span class="pre">taxon_is_species_rank</span></tt> that needs no explanation, especially if the variable is only used once or twice.</li>
</ul>
<div class="section">
<h4><a class="toc-backref" href="#id61" id="acceptable-abbreviations" name="acceptable-abbreviations">Acceptable abbreviations</a></h4>
<p>The following list of abbreviations can be considered well-known and used with impunity within mixed name variables, but some should not be used by themselves as they would conflict with common functions, python built-in's, or raise an exception. Do not use the following by themselves as variable names: <tt class="docutils literal"><span class="pre">dir</span></tt>,  <tt class="docutils literal"><span class="pre">exp</span></tt> (a common <tt class="docutils literal"><span class="pre">math</span></tt> module function), <tt class="docutils literal"><span class="pre">in</span></tt>, <tt class="docutils literal"><span class="pre">max</span></tt>, and <tt class="docutils literal"><span class="pre">min</span></tt>. They can, however, be used as part of a name, eg <tt class="docutils literal"><span class="pre">matrix_exp</span></tt>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="41%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Full</th>
<th class="head">Abbreviated</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>alignment</td>
<td>aln</td>
</tr>
<tr><td>archaeal</td>
<td>arch</td>
</tr>
<tr><td>auxillary</td>
<td>aux</td>
</tr>
<tr><td>bacterial</td>
<td>bact</td>
</tr>
<tr><td>citation</td>
<td>cite</td>
</tr>
<tr><td>current</td>
<td>curr</td>
</tr>
<tr><td>database</td>
<td>db</td>
</tr>
<tr><td>dictionary</td>
<td>dict</td>
</tr>
<tr><td>directory</td>
<td>dir</td>
</tr>
<tr><td>end of file</td>
<td>eof</td>
</tr>
<tr><td>eukaryotic</td>
<td>euk</td>
</tr>
<tr><td>frequency</td>
<td>freq</td>
</tr>
<tr><td>expected</td>
<td>exp</td>
</tr>
<tr><td>index</td>
<td>idx</td>
</tr>
<tr><td>input</td>
<td>in</td>
</tr>
<tr><td>maximum</td>
<td>max</td>
</tr>
<tr><td>minimum</td>
<td>min</td>
</tr>
<tr><td>mitochondrial</td>
<td>mt</td>
</tr>
<tr><td>number</td>
<td>num</td>
</tr>
<tr><td>observed</td>
<td>obs</td>
</tr>
<tr><td>original</td>
<td>orig</td>
</tr>
<tr><td>output</td>
<td>out</td>
</tr>
<tr><td>parameter</td>
<td>param</td>
</tr>
<tr><td>phylogeny</td>
<td>phylo</td>
</tr>
<tr><td>previous</td>
<td>prev</td>
</tr>
<tr><td>probability</td>
<td>prob</td>
</tr>
<tr><td>protein</td>
<td>prot</td>
</tr>
<tr><td>record</td>
<td>rec</td>
</tr>
<tr><td>reference</td>
<td>ref</td>
</tr>
<tr><td>sequence</td>
<td>seq</td>
</tr>
<tr><td>standard deviation</td>
<td>stdev</td>
</tr>
<tr><td>statistics</td>
<td>stats</td>
</tr>
<tr><td>string</td>
<td>str</td>
</tr>
<tr><td>structure</td>
<td>struct</td>
</tr>
<tr><td>temporary</td>
<td>temp</td>
</tr>
<tr><td>taxonomic</td>
<td>tax</td>
</tr>
<tr><td>variance</td>
<td>var</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id62" id="what-are-the-naming-conventions" name="what-are-the-naming-conventions">What are the naming conventions?</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Type</th>
<th class="head">Convention</th>
<th class="head">Example</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>function</td>
<td><tt class="docutils literal"><span class="pre">verb_with_underscores</span></tt></td>
<td><tt class="docutils literal"><span class="pre">find_all</span></tt></td>
</tr>
<tr><td>variable</td>
<td><tt class="docutils literal"><span class="pre">noun_with_underscores</span></tt></td>
<td><tt class="docutils literal"><span class="pre">curr_index</span></tt></td>
</tr>
<tr><td>constant</td>
<td><tt class="docutils literal"><span class="pre">NOUN_ALL_CAPS</span></tt></td>
<td><tt class="docutils literal"><span class="pre">ALLOWED_RNA_PAIRS</span></tt></td>
</tr>
<tr><td>class</td>
<td><tt class="docutils literal"><span class="pre">MixedCaseNoun</span></tt></td>
<td><tt class="docutils literal"><span class="pre">RnaSequence</span></tt></td>
</tr>
<tr><td>public property</td>
<td><tt class="docutils literal"><span class="pre">MixedCaseNoun</span></tt></td>
<td><tt class="docutils literal"><span class="pre">IsPaired</span></tt></td>
</tr>
<tr><td>private property</td>
<td><tt class="docutils literal"><span class="pre">_noun_with_leading_underscore</span></tt></td>
<td><tt class="docutils literal"><span class="pre">_is_updated</span></tt></td>
</tr>
<tr><td>public method</td>
<td><tt class="docutils literal"><span class="pre">mixedCaseExceptFirstWordVerb</span></tt></td>
<td><tt class="docutils literal"><span class="pre">stripDegenerate</span></tt></td>
</tr>
<tr><td>private method</td>
<td><tt class="docutils literal"><span class="pre">_verb_with_leading_underscore</span></tt></td>
<td><tt class="docutils literal"><span class="pre">_check_if_paired</span></tt></td>
</tr>
<tr><td>really private data</td>
<td><tt class="docutils literal"><span class="pre">__two_leading_underscores</span></tt></td>
<td><tt class="docutils literal"><span class="pre">__delegator_object_ref</span></tt></td>
</tr>
<tr><td>parameters that match properties</td>
<td><tt class="docutils literal"><span class="pre">SameAsProperty</span></tt></td>
<td><tt class="docutils literal"><span class="pre">def</span> <span class="pre">__init__(data,</span> <span class="pre">Alphabet=None)</span></tt></td>
</tr>
<tr><td>factory function</td>
<td><tt class="docutils literal"><span class="pre">MixedCase</span></tt></td>
<td><tt class="docutils literal"><span class="pre">InverseDict</span></tt></td>
</tr>
<tr><td>module</td>
<td><tt class="docutils literal"><span class="pre">lowercase_with_underscores</span></tt></td>
<td><tt class="docutils literal"><span class="pre">unit_test</span></tt></td>
</tr>
<tr><td>global variables</td>
<td><tt class="docutils literal"><span class="pre">gMixedCaseWithLeadingG</span></tt></td>
<td>no examples in evo - should be rare!</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><em>It is important to follow the naming conventions because they make it much easier to guess what a name refers to</em>. In particular, it should be easy to guess what scope a name is defined in, what it refers to, whether it's OK to change its value, and whether its referent is callable. The following rules provide these distinctions.</li>
<li><tt class="docutils literal"><span class="pre">lowercase_with_underscores</span></tt> <em>for modules and internal variables (including function/method parameters).</em></li>
<li><tt class="docutils literal"><span class="pre">MixedCase</span></tt> for <em>classes</em> and <em>public properties</em>, and for <em>factory functions</em> that act like additional constructors for a class.</li>
<li><tt class="docutils literal"><span class="pre">mixedCaseExceptFirstWord</span></tt> for <em>public methods and functions</em>.</li>
<li><tt class="docutils literal"><span class="pre">_lowercase_with_leading_underscore</span></tt> for <em>private</em> functions, methods, and properties.</li>
<li><tt class="docutils literal"><span class="pre">__lowercase_with_two_leading_underscores</span></tt> for <em>private</em> properties and functions that <em>must not be overwritten</em> by a subclass.</li>
<li><tt class="docutils literal"><span class="pre">CAPS_WITH_UNDERSCORES</span></tt> for named <em>constants</em>.</li>
<li><tt class="docutils literal"><span class="pre">gMixedCase</span></tt> (i.e. mixed case prefixed with 'g') for <em>globals</em>. Globals should be used extremely rarely and with caution, even if you sneak them in using the Singleton pattern or some similar system.</li>
<li><em>Underscores can be left out if the words read OK run together.</em> <tt class="docutils literal"><span class="pre">infile</span></tt> and <tt class="docutils literal"><span class="pre">outfile</span></tt> rather than <tt class="docutils literal"><span class="pre">in_file</span></tt> and <tt class="docutils literal"><span class="pre">out_file</span></tt>; <tt class="docutils literal"><span class="pre">infile_name</span></tt> and <tt class="docutils literal"><span class="pre">outfile_name</span></tt> rather than <tt class="docutils literal"><span class="pre">in_file_name</span></tt> and <tt class="docutils literal"><span class="pre">out_file_name</span></tt> or <tt class="docutils literal"><span class="pre">infilename</span></tt> and <tt class="docutils literal"><span class="pre">outfilename</span></tt> (getting too long to read effortlessly).</li>
</ul>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id63" id="how-do-i-organize-my-modules-source-files" name="how-do-i-organize-my-modules-source-files">How do I organize my modules (source files)?</a></h3>
<ul class="simple">
<li><em>Have a docstring with a description of the module's functions</em>. If the description is long, the first line should be a short summary that makes sense on its own, separated from the rest by a newline.</li>
<li><em>All code, including import statements, should follow the docstring.</em> Otherwise, the docstring will not be recognized by the interpreter, and you will not have access to it in interactive sessions (i.e. through <tt class="docutils literal"><span class="pre">obj.__doc__</span></tt>) or when generating documentation with automated tools.</li>
<li><em>Import built-in modules first, followed by third-party modules, followed by any changes to the path and your own modules.</em> Especially, additions to the path and names of your modules are likely to change rapidly: keeping them in one place makes them easier to find.</li>
<li><em>Don't use</em> <tt class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></tt>, <em>instead use</em> <tt class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">Name,</span> <span class="pre">Name2,</span> <span class="pre">Name3...</span></tt> <em>or possibly</em> <tt class="docutils literal"><span class="pre">import</span> <span class="pre">module</span></tt>. This makes it <em>much</em> easier to see name collisions and to replace implementations.</li>
</ul>
<div class="section">
<h4><a class="toc-backref" href="#id64" id="example-of-module-structure" name="example-of-module-structure">Example of module structure</a></h4>
<pre class="literal-block">
#!/usr/bin/env python

&quot;&quot;&quot;Provides NumberList and FrequencyDistribution, classes for statistics.

NumberList holds a sequence of numbers, and defines several statistical
operations (mean, stdev, etc.) FrequencyDistribution holds a mapping from
items (not necessarily numbers) to counts, and defines operations such as
Shannon entropy and frequency normalization.
&quot;&quot;&quot;

from math import sqrt, log, e
from random import choice, random
from Utils import indices

class NumberList(list):
    pass    # much code deleted
class FrequencyDistribution(dict):
    pass    # much code deleted

# use the following when the module can meaningfully be called as a script.
if __name__ == '__main__':    # code to execute if called from command-line
    pass    # do nothing - code deleted
</pre>
</div>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id65" id="how-should-i-write-comments" name="how-should-i-write-comments">How should I write comments?</a></h3>
<ul>
<li><p class="first"><em>Always update the comments when the code changes.</em> Incorrect comments are far worse than no comments, since they are actively misleading.</p>
</li>
<li><p class="first"><em>Comments should say more than the code itself.</em> Examine your comments carefully: they may indicate that you'd be better off rewriting your code (especially, <em>renaming your variables</em> and getting rid of the comment.) In particular, don't scatter magic numbers and other constants that have to be explained through your code. It's far better to use variables whose names are self-documenting, especially if you use the same constant more than once. Also, think about making constants into class or instance data, since it's all too common for 'constants' to need to change or to be needed in several methods.</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr><td><p class="first last">Wrong</p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">win_size</span> <span class="pre">-=</span> <span class="pre">20</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">#</span> <span class="pre">decrement</span> <span class="pre">win_size</span> <span class="pre">by</span> <span class="pre">20</span></tt></p>
</td>
</tr>
<tr><td><p class="first last">OK</p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">win_size</span> <span class="pre">-=</span> <span class="pre">20</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">#</span> <span class="pre">leave</span> <span class="pre">space</span> <span class="pre">for</span> <span class="pre">the</span> <span class="pre">scroll</span> <span class="pre">bar</span></tt></p>
</td>
</tr>
<tr><td><p class="first last">Right</p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">self._scroll_bar_size</span> <span class="pre">=</span> <span class="pre">20</span></tt></p>
</td>
</tr>
<tr><td>&nbsp;</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">win_size</span> <span class="pre">-=</span> <span class="pre">self._scroll_bar_size</span></tt></p>
</td>
</tr>
</tbody>
</table>
</blockquote>
</li>
<li><p class="first"><em>Use comments starting with #, not strings, inside blocks of code.</em> Python ignores real comments, but must allocate storage for strings (which can be a performance disaster inside an inner loop).</p>
</li>
<li><p class="first"><em>Start each method, class and function with a docstring using triple double quotes (&quot;&quot;&quot;).</em> The docstring should start with a 1-line description that makes sense by itself (many automated formatting tools, and the IDE, use this). This should be followed by a blank line, followed by descriptions of the parameters (if any). Finally, add any more detailed information, such as a longer description, notes about the algorithm, detailed notes about the parameters, etc. If there is a usage example, it should appear at the end. Make sure any descriptions of parameters have the correct spelling, case, etc. For example:</p>
<pre class="literal-block">
def __init__(self, data, name='', alphabet=None):
    &quot;&quot;&quot;Returns new Sequence object with specified data, name, alphabet.

    Arguments:

        - data: The sequence data. Should be a sequence of characters.
        - name: Arbitrary label for the sequence. Should be string-like.
        - alphabet: Set of allowed characters. Should support 'for x in y'
          syntax. None by default.

    Note: if alphabet is None, performs no validation.
    &quot;&quot;&quot;
</pre>
</li>
<li><p class="first"><em>Always update the docstring when the code changes.</em> Like outdated comments, outdated docstrings can waste a lot of time. &quot;Correct examples are priceless, but incorrect examples are worse than worthless.&quot; <a class="reference" href="http://www.python.org/pycon/dc2004/papers/4/PyCon2004DocTestUnit.pdf">Jim Fulton</a>.</p>
</li>
</ul>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id66" id="how-should-i-format-my-code" name="how-should-i-format-my-code">How should I format my code?</a></h3>
<ul>
<li><p class="first"><em>Use 4 spaces for indentation.</em> Do not use tabs (set your editor to convert tabs to spaces). The behaviour of tabs is not predictable across platforms, and will cause syntax errors. If we all use the same indentation, collaboration is much easier.</p>
</li>
<li><p class="first"><em>Lines should not be longer than 79 characters.</em> Long lines are inconvenient in some editors. Use \ for line continuation. Note that there cannot be whitespace after the \.</p>
</li>
<li><p class="first"><em>Blank lines should be used to highlight class and method definitions.</em> Separate class definitions by two blank lines. Separate methods by one blank line.</p>
</li>
<li><p class="first"><em>Be consistent with the use of whitespace around operators.</em> Inconsistent whitespace makes it harder to see at a glance what is grouped together.</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr><td><p class="first last">Good</p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">((a+b)*(c+d))</span></tt></p>
</td>
</tr>
<tr><td><p class="first last">OK</p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">((a</span> <span class="pre">+</span> <span class="pre">b)</span> <span class="pre">*</span> <span class="pre">(c</span> <span class="pre">+</span> <span class="pre">d))</span></tt></p>
</td>
</tr>
<tr><td><p class="first last">Bad</p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">(</span> <span class="pre">(a+</span> <span class="pre">b)</span>&nbsp; <span class="pre">*(c</span> <span class="pre">+d</span>&nbsp; <span class="pre">))</span></tt></p>
</td>
</tr>
</tbody>
</table>
</blockquote>
</li>
<li><p class="first"><em>Don't put whitespace after delimiters or inside slicing delimiters.</em> Whitespace here makes it harder to see what's associated.</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="35%" />
<col width="49%" />
</colgroup>
<tbody valign="top">
<tr><td><p class="first last">Good</p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">(a+b)</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">d[k]</span></tt></p>
</td>
</tr>
<tr><td><p class="first last">Bad</p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">(</span> <span class="pre">a+b</span> <span class="pre">)</span></tt></p>
</td>
<td><p class="first last"><tt class="docutils literal"><span class="pre">d</span> <span class="pre">[k],</span> <span class="pre">d[</span> <span class="pre">k]</span></tt></p>
</td>
</tr>
</tbody>
</table>
</blockquote>
</li>
</ul>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id67" id="how-should-i-test-my-code" name="how-should-i-test-my-code">How should I test my code ?</a></h3>
<p>There are two basic approaches for testing code in python: unit testing and doc testing. Their purpose is the same, to check that execution of code given some input produces a specified output. The cases to which the two approaches lend themselves are different.</p>
<p>An excellent discourse on testing code and the pros and cons of these alternatives is provided in a presentation by <a class="reference" href="http://www.python.org/pycon/dc2004/papers/4/PyCon2004DocTestUnit.pdf">Jim Fulton</a>, which is recommended reading. A significant change since that presentation is that <tt class="docutils literal"><span class="pre">doctest</span></tt> can now read content that is not contained within docstrings. A another comparison of these two approaches, along with a third (<tt class="docutils literal"><span class="pre">py.test</span></tt>) is also <a class="reference" href="http://agiletesting.blogspot.com/2005/11/articles-and-tutorials-page-updated.html">available</a>. To see examples of both styles of testing look in <tt class="docutils literal"><span class="pre">Cogent/tests</span></tt>: files ending in .rest are using <tt class="docutils literal"><span class="pre">doctest</span></tt>, those ending in .py are using <tt class="docutils literal"><span class="pre">unittest</span></tt>.</p>
<p>In general, it's easier to start writing <tt class="docutils literal"><span class="pre">doctest</span></tt>'s, as you don't need to learn the <tt class="docutils literal"><span class="pre">unittest</span></tt> API but the latter give's much greater control.</p>
<p>Whatever approach is employed, the general principle is every line of code should be tested. It is critical that your code be fully tested before you draw conclusions from results it produces. For scientific work, bugs don't just mean unhappy users who you'll never actually meet: they may mean retracted publications.</p>
<p>Tests are an opportunity to invent the interface(s) you want. Write the test for a method before you write the method: often, this helps you figure out what you would want to call it and what parameters it should take. It's OK to write the tests a few methods at a time, and to change them as your ideas about the interface change. However, you shouldn't change them once you've told other people what the interface is.</p>
<p>Never treat prototypes as production code. It's fine to write prototype code without tests to try things out, but when you've figured out the algorithm and interfaces you must rewrite it <em>with tests</em> to consider it finished. Often, this helps you decide what interfaces and functionality you actually need and what you can get rid of.</p>
<p>&quot;Code a little test a little&quot;. For production code, write a couple of tests, then a couple of methods, then a couple more tests, then a couple more methods, then maybe change some of the names or generalize some of the functionality. If you have a huge amount of code where 'all you have to do is write the tests', you're probably closer to 30% done than 90%. Testing vastly reduces the time spent debugging, since whatever went wrong has to be in the code you wrote since the last test suite. And remember to use python's interactive interpreter for quick checks of syntax and ideas.</p>
<p>Run the test suite when you change <cite>anything</cite>. Even if a change seems trivial, it will only take a couple of seconds to run the tests and then you'll be sure. This can eliminate long and frustrating debugging sessions where the change turned out to have been made long ago, but didn't seem significant at the time.</p>
<div class="section">
<h4><a class="toc-backref" href="#id68" id="some-unittest-pointers" name="some-unittest-pointers">Some <tt class="docutils literal"><span class="pre">unittest</span></tt> pointers</a></h4>
<ul>
<li><p class="first"><em>Use the</em> <tt class="docutils literal"><span class="pre">unittest</span></tt> <em>framework with tests in a separate file for each module.</em> Name the test file <tt class="docutils literal"><span class="pre">test_module_name.py</span></tt>. Keeping the tests separate from the code reduces the temptation to change the tests when the code doesn't work, and makes it easy to verify that a completely new implementation presents the same interface (behaves the same) as the old.</p>
</li>
<li><p class="first"><em>Use</em> <tt class="docutils literal"><span class="pre">evo.unit_test</span></tt> <em>if you are doing anything with floating point numbers or permutations</em> (use <tt class="docutils literal"><span class="pre">assertFloatEqual</span></tt>). Do <em>not</em> try to compare floating point numbers using <tt class="docutils literal"><span class="pre">assertEqual</span></tt> if you value your sanity. <tt class="docutils literal"><span class="pre">assertFloatEqualAbs</span></tt> and <tt class="docutils literal"><span class="pre">assertFloatEqualRel</span></tt> can specifically test for absolute and relative differences if the default behavior is not giving you what you want. Similarly, <tt class="docutils literal"><span class="pre">assertEqualItems</span></tt>, <tt class="docutils literal"><span class="pre">assertSameItems</span></tt>, etc. can be useful when testing permutations.</p>
</li>
<li><p class="first"><em>Test the interface of each class in your code by defining at least one</em> <tt class="docutils literal"><span class="pre">TestCase</span></tt> <em>with the name</em> <tt class="docutils literal"><span class="pre">ClassNameTests</span></tt>. This should contain tests for everything in the public interface.</p>
</li>
<li><p class="first"><em>If the class is complicated, you may want to define additional tests with names</em> <tt class="docutils literal"><span class="pre">ClassNameTests_test_type</span></tt>. These might subclass <tt class="docutils literal"><span class="pre">ClassNameTests</span></tt> in order to share <tt class="docutils literal"><span class="pre">setUp</span></tt> methods, etc.</p>
</li>
<li><p class="first"><em>Tests of private methods should be in a separate</em> <tt class="docutils literal"><span class="pre">TestCase</span></tt> <em>called</em> <tt class="docutils literal"><span class="pre">ClassNameTests_private</span></tt>. Private methods may change if you change the implementation. It is not required that test cases for private methods pass when you change things (that's why they're private, after all), though it is often useful to have these tests for debugging.</p>
</li>
<li><p class="first"><em>Test `all` the methods in your class.</em> You should assume that any method you haven't tested has bugs. The convention for naming tests is <tt class="docutils literal"><span class="pre">test_method_name</span></tt>. Any leading and trailing underscores on the method name can be ignored for the purposes of the test; however, <em>all tests must start with the literal substring</em> <tt class="docutils literal"><span class="pre">test</span></tt> <em>for</em> <tt class="docutils literal"><span class="pre">unittest</span></tt> <em>to find them.</em> If the method is particularly complex, or has several discretely different cases you need to check, use <tt class="docutils literal"><span class="pre">test_method_name_suffix</span></tt>, e.g. <tt class="docutils literal"><span class="pre">test_init_empty</span></tt>, <tt class="docutils literal"><span class="pre">test_init_single</span></tt>, <tt class="docutils literal"><span class="pre">test_init_wrong_type</span></tt>, etc. for testing <tt class="docutils literal"><span class="pre">__init__</span></tt>.</p>
</li>
<li><p class="first"><em>Write good docstrings for all your test methods.</em> When you run the test with the <tt class="docutils literal"><span class="pre">-v</span></tt> command-line switch for verbose output, the docstring for each test will be printed along with <tt class="docutils literal"><span class="pre">...OK</span></tt> or <tt class="docutils literal"><span class="pre">...FAILED</span></tt> on a single line. It is thus important that your docstring is short and descriptive, and makes sense in this context.</p>
<blockquote>
<p><strong>Good docstrings:</strong></p>
<pre class="literal-block">
NumberList.var should raise ValueError on empty or 1-item list
NumberList.var should match values from R if list has &gt;2 items
NumberList.__init__ should raise error on values that fail float()
FrequencyDistribution.var should match corresponding NumberList var
</pre>
<p><strong>Bad docstrings:</strong></p>
<pre class="literal-block">
var should calculate variance           # lacks class name, not descriptive
Check initialization of a NumberList    # doesn't say what's expected
Tests of the NumberList initialization. # ditto
</pre>
</blockquote>
</li>
<li><p class="first"><em>Module-level functions should be tested in their own</em> <tt class="docutils literal"><span class="pre">TestCase</span></tt><em>, called</em> <tt class="docutils literal"><span class="pre">modulenameTests</span></tt>. Even if these functions are simple, it's important to check that they work as advertised.</p>
</li>
<li><p class="first"><em>It is much more important to test several small cases that you can check by hand than a single large case that requires a calculator.</em> Don't trust spreadsheets for numerical calculations -- use R instead!</p>
</li>
<li><p class="first"><em>Make sure you test all the edge cases: what happens when the input is None, or '', or 0, or negative?</em> What happens at values that cause a conditional to go one way or the other? Does incorrect input raise the right exceptions? Can your code accept subclasses or superclasses of the types it expects? What happens with very large input?</p>
</li>
<li><p class="first"><em>To test permutations, check that the original and shuffled version are different, but that the sorted original and sorted shuffled version are the same.</em> Make sure that you get <em>different</em> permutations on repeated runs and when starting from different points.</p>
</li>
<li><p class="first"><em>To test random choices, figure out how many of each choice you expect in a large sample (say, 1000 or a million) using the binomial distribution or its normal approximation.</em> Run the test several times and check that you're within, say, 3 standard deviations of the mean.</p>
</li>
</ul>
</div>
<div class="section">
<h4><a class="toc-backref" href="#id69" id="example-of-a-unittest-test-module-structure" name="example-of-a-unittest-test-module-structure">Example of a <tt class="docutils literal"><span class="pre">unittest</span></tt> test module structure</a></h4>
<pre class="literal-block">
#!/usr/bin/env python

&quot;&quot;&quot;Tests NumberList and FrequencyDistribution, classes for statistics.&quot;&quot;&quot;

from unittest import TestCase, main # for floating point test use unittestfp
from statistics import NumberList, FrequencyDistribution

class NumberListTests(TestCase): # remember to subclass TestCase
    &quot;&quot;&quot;Tests of the NumberList class.&quot;&quot;&quot;
    def setUp(self):
        &quot;&quot;&quot;Define a few standard NumberLists.&quot;&quot;&quot;
        self.Null = NumberList()            # test empty init
        self.Empty = NumberList([])         # test init with empty sequence
        self.Single = NumberList([5])       # single item
        self.Zero = NumberList([0])         # single, False item
        self.Three = NumberList([1,2,3])    # multiple items
        self.ZeroMean = NumberList([1,-1])  # items nonzero, mean zero
        self.ZeroVar = NumberList([1,1,1])  # items nonzero, mean nonzero, variance zero
        # etc. These objects shared by all tests, and created new each time a method
        # starting with the string 'test' is called (i.e. the same object does not
        # persist between tests: rather, you get separate copies).

        def test_mean_empty(self):
            &quot;&quot;&quot;NumberList.mean() should raise ValueError on empty object&quot;&quot;&quot;
            for empty in (self.Null, self.Empty):
                self.assertRaises(ValueError, empty.mean)
        def test_mean_single(self):
            &quot;&quot;&quot;NumberList.mean() should return item if only 1 item in list&quot;&quot;&quot;
            for single in (self.Single, self.Zero):
                self.assertEqual(single.mean(), single[0])
        # other tests of mean
        def test_var_failures(self):
            &quot;&quot;&quot;NumberList.var() should raise ZeroDivisionError if &lt;2 items&quot;&quot;&quot;
            for small in (self.Null, self.Empty, self.Single, self.Zero):
                self.assertRaises(ZeroDivisionError, small.var)
        # other tests of var
        # tests of other methods

class FrequencyDistributionTests(TestCase):
    pass    # much code deleted
# tests of other classes

if __name__ == '__main__':    # run tests if called from command-line
    main()
</pre>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
